schema {
  query: query_root
  subscription: subscription_root
}

"Boolean expression to compare columns of type \"Boolean\". All fields are combined with logical 'AND'."
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"Boolean expression to compare columns of type \"String\". All fields are combined with logical 'AND'."
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  "does the column match the given case-insensitive pattern"
  _ilike: String
  _in: [String!]
  "does the column match the given POSIX regular expression, case insensitive"
  _iregex: String
  _is_null: Boolean
  "does the column match the given pattern"
  _like: String
  _lt: String
  _lte: String
  _neq: String
  "does the column NOT match the given case-insensitive pattern"
  _nilike: String
  _nin: [String!]
  "does the column NOT match the given POSIX regular expression, case insensitive"
  _niregex: String
  "does the column NOT match the given pattern"
  _nlike: String
  "does the column NOT match the given POSIX regular expression, case sensitive"
  _nregex: String
  "does the column NOT match the given SQL regular expression"
  _nsimilar: String
  "does the column match the given POSIX regular expression, case sensitive"
  _regex: String
  "does the column match the given SQL regular expression"
  _similar: String
}

"columns and relationships of \"account_transactions\""
type account_transactions {
  account_address: String!
  "An array relationship"
  coin_activities("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "An aggregate relationship"
  coin_activities_aggregate("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): coin_activities_aggregate!
  "An array relationship"
  delegated_staking_activities("distinct select on columns" distinct_on: [delegated_staking_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_activities_order_by!] "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "An array relationship"
  fungible_asset_activities("distinct select on columns" distinct_on: [fungible_asset_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fungible_asset_activities_order_by!] "filter the rows returned" where: fungible_asset_activities_bool_exp): [fungible_asset_activities!]!
  "An array relationship"
  token_activities("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An aggregate relationship"
  token_activities_aggregate("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): token_activities_aggregate!
  "An array relationship"
  token_activities_v2("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "An aggregate relationship"
  token_activities_v2_aggregate("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): token_activities_v2_aggregate!
  transaction_version: bigint!
  "An object relationship"
  user_transaction: user_transactions
}

"aggregated selection of \"account_transactions\""
type account_transactions_aggregate {
  aggregate: account_transactions_aggregate_fields
  nodes: [account_transactions!]!
}

"aggregate fields of \"account_transactions\""
type account_transactions_aggregate_fields {
  avg: account_transactions_avg_fields
  count(columns: [account_transactions_select_column!] distinct: Boolean): Int!
  max: account_transactions_max_fields
  min: account_transactions_min_fields
  stddev: account_transactions_stddev_fields
  stddev_pop: account_transactions_stddev_pop_fields
  stddev_samp: account_transactions_stddev_samp_fields
  sum: account_transactions_sum_fields
  var_pop: account_transactions_var_pop_fields
  var_samp: account_transactions_var_samp_fields
  variance: account_transactions_variance_fields
}

"aggregate avg on columns"
type account_transactions_avg_fields {
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"account_transactions\". All fields are combined with a logical 'AND'."
input account_transactions_bool_exp {
  _and: [account_transactions_bool_exp!]
  _not: account_transactions_bool_exp
  _or: [account_transactions_bool_exp!]
  account_address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  fungible_asset_activities: fungible_asset_activities_bool_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
  user_transaction: user_transactions_bool_exp
}

"aggregate max on columns"
type account_transactions_max_fields {
  account_address: String
  transaction_version: bigint
}

"aggregate min on columns"
type account_transactions_min_fields {
  account_address: String
  transaction_version: bigint
}

"Ordering options when selecting data from \"account_transactions\"."
input account_transactions_order_by {
  account_address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  fungible_asset_activities_aggregate: fungible_asset_activities_aggregate_order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
  user_transaction: user_transactions_order_by
}

"select columns of table \"account_transactions\""
enum account_transactions_select_column {
  "column name"
  account_address
  "column name"
  transaction_version
}

"aggregate stddev on columns"
type account_transactions_stddev_fields {
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type account_transactions_stddev_pop_fields {
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type account_transactions_stddev_samp_fields {
  transaction_version: Float
}

"Streaming cursor of the table \"account_transactions\""
input account_transactions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: account_transactions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input account_transactions_stream_cursor_value_input {
  account_address: String
  transaction_version: bigint
}

"aggregate sum on columns"
type account_transactions_sum_fields {
  transaction_version: bigint
}

"aggregate var_pop on columns"
type account_transactions_var_pop_fields {
  transaction_version: Float
}

"aggregate var_samp on columns"
type account_transactions_var_samp_fields {
  transaction_version: Float
}

"aggregate variance on columns"
type account_transactions_variance_fields {
  transaction_version: Float
}

"columns and relationships of \"address_events_summary\""
type address_events_summary {
  account_address: String
  "An object relationship"
  block_metadata: block_metadata_transactions
  min_block_height: bigint
  num_distinct_versions: bigint
}

"Boolean expression to filter rows from the table \"address_events_summary\". All fields are combined with a logical 'AND'."
input address_events_summary_bool_exp {
  _and: [address_events_summary_bool_exp!]
  _not: address_events_summary_bool_exp
  _or: [address_events_summary_bool_exp!]
  account_address: String_comparison_exp
  block_metadata: block_metadata_transactions_bool_exp
  min_block_height: bigint_comparison_exp
  num_distinct_versions: bigint_comparison_exp
}

"Ordering options when selecting data from \"address_events_summary\"."
input address_events_summary_order_by {
  account_address: order_by
  block_metadata: block_metadata_transactions_order_by
  min_block_height: order_by
  num_distinct_versions: order_by
}

"select columns of table \"address_events_summary\""
enum address_events_summary_select_column {
  "column name"
  account_address
  "column name"
  min_block_height
  "column name"
  num_distinct_versions
}

"Streaming cursor of the table \"address_events_summary\""
input address_events_summary_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: address_events_summary_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input address_events_summary_stream_cursor_value_input {
  account_address: String
  min_block_height: bigint
  num_distinct_versions: bigint
}

"columns and relationships of \"address_version_from_events\""
type address_version_from_events {
  account_address: String
  "An array relationship"
  coin_activities("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "An aggregate relationship"
  coin_activities_aggregate("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): coin_activities_aggregate!
  "An array relationship"
  delegated_staking_activities("distinct select on columns" distinct_on: [delegated_staking_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_activities_order_by!] "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "An array relationship"
  token_activities("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An aggregate relationship"
  token_activities_aggregate("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): token_activities_aggregate!
  "An array relationship"
  token_activities_v2("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "An aggregate relationship"
  token_activities_v2_aggregate("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): token_activities_v2_aggregate!
  transaction_version: bigint
}

"aggregated selection of \"address_version_from_events\""
type address_version_from_events_aggregate {
  aggregate: address_version_from_events_aggregate_fields
  nodes: [address_version_from_events!]!
}

"aggregate fields of \"address_version_from_events\""
type address_version_from_events_aggregate_fields {
  avg: address_version_from_events_avg_fields
  count(columns: [address_version_from_events_select_column!] distinct: Boolean): Int!
  max: address_version_from_events_max_fields
  min: address_version_from_events_min_fields
  stddev: address_version_from_events_stddev_fields
  stddev_pop: address_version_from_events_stddev_pop_fields
  stddev_samp: address_version_from_events_stddev_samp_fields
  sum: address_version_from_events_sum_fields
  var_pop: address_version_from_events_var_pop_fields
  var_samp: address_version_from_events_var_samp_fields
  variance: address_version_from_events_variance_fields
}

"aggregate avg on columns"
type address_version_from_events_avg_fields {
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"address_version_from_events\". All fields are combined with a logical 'AND'."
input address_version_from_events_bool_exp {
  _and: [address_version_from_events_bool_exp!]
  _not: address_version_from_events_bool_exp
  _or: [address_version_from_events_bool_exp!]
  account_address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
}

"aggregate max on columns"
type address_version_from_events_max_fields {
  account_address: String
  transaction_version: bigint
}

"aggregate min on columns"
type address_version_from_events_min_fields {
  account_address: String
  transaction_version: bigint
}

"Ordering options when selecting data from \"address_version_from_events\"."
input address_version_from_events_order_by {
  account_address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
}

"select columns of table \"address_version_from_events\""
enum address_version_from_events_select_column {
  "column name"
  account_address
  "column name"
  transaction_version
}

"aggregate stddev on columns"
type address_version_from_events_stddev_fields {
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type address_version_from_events_stddev_pop_fields {
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type address_version_from_events_stddev_samp_fields {
  transaction_version: Float
}

"Streaming cursor of the table \"address_version_from_events\""
input address_version_from_events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: address_version_from_events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input address_version_from_events_stream_cursor_value_input {
  account_address: String
  transaction_version: bigint
}

"aggregate sum on columns"
type address_version_from_events_sum_fields {
  transaction_version: bigint
}

"aggregate var_pop on columns"
type address_version_from_events_var_pop_fields {
  transaction_version: Float
}

"aggregate var_samp on columns"
type address_version_from_events_var_samp_fields {
  transaction_version: Float
}

"aggregate variance on columns"
type address_version_from_events_variance_fields {
  transaction_version: Float
}

"columns and relationships of \"legacy_migration_v1.address_version_from_move_resources\""
type address_version_from_move_resources {
  address: String
  "An array relationship"
  coin_activities("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "An aggregate relationship"
  coin_activities_aggregate("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): coin_activities_aggregate!
  "An array relationship"
  delegated_staking_activities("distinct select on columns" distinct_on: [delegated_staking_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_activities_order_by!] "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "An array relationship"
  token_activities("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An aggregate relationship"
  token_activities_aggregate("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): token_activities_aggregate!
  "An array relationship"
  token_activities_v2("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "An aggregate relationship"
  token_activities_v2_aggregate("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): token_activities_v2_aggregate!
  transaction_version: bigint
}

"aggregated selection of \"legacy_migration_v1.address_version_from_move_resources\""
type address_version_from_move_resources_aggregate {
  aggregate: address_version_from_move_resources_aggregate_fields
  nodes: [address_version_from_move_resources!]!
}

"aggregate fields of \"legacy_migration_v1.address_version_from_move_resources\""
type address_version_from_move_resources_aggregate_fields {
  avg: address_version_from_move_resources_avg_fields
  count(columns: [address_version_from_move_resources_select_column!] distinct: Boolean): Int!
  max: address_version_from_move_resources_max_fields
  min: address_version_from_move_resources_min_fields
  stddev: address_version_from_move_resources_stddev_fields
  stddev_pop: address_version_from_move_resources_stddev_pop_fields
  stddev_samp: address_version_from_move_resources_stddev_samp_fields
  sum: address_version_from_move_resources_sum_fields
  var_pop: address_version_from_move_resources_var_pop_fields
  var_samp: address_version_from_move_resources_var_samp_fields
  variance: address_version_from_move_resources_variance_fields
}

"aggregate avg on columns"
type address_version_from_move_resources_avg_fields {
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.address_version_from_move_resources\". All fields are combined with a logical 'AND'."
input address_version_from_move_resources_bool_exp {
  _and: [address_version_from_move_resources_bool_exp!]
  _not: address_version_from_move_resources_bool_exp
  _or: [address_version_from_move_resources_bool_exp!]
  address: String_comparison_exp
  coin_activities: coin_activities_bool_exp
  coin_activities_aggregate: coin_activities_aggregate_bool_exp
  delegated_staking_activities: delegated_staking_activities_bool_exp
  token_activities: token_activities_bool_exp
  token_activities_aggregate: token_activities_aggregate_bool_exp
  token_activities_v2: token_activities_v2_bool_exp
  token_activities_v2_aggregate: token_activities_v2_aggregate_bool_exp
  transaction_version: bigint_comparison_exp
}

"aggregate max on columns"
type address_version_from_move_resources_max_fields {
  address: String
  transaction_version: bigint
}

"aggregate min on columns"
type address_version_from_move_resources_min_fields {
  address: String
  transaction_version: bigint
}

"Ordering options when selecting data from \"legacy_migration_v1.address_version_from_move_resources\"."
input address_version_from_move_resources_order_by {
  address: order_by
  coin_activities_aggregate: coin_activities_aggregate_order_by
  delegated_staking_activities_aggregate: delegated_staking_activities_aggregate_order_by
  token_activities_aggregate: token_activities_aggregate_order_by
  token_activities_v2_aggregate: token_activities_v2_aggregate_order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.address_version_from_move_resources\""
enum address_version_from_move_resources_select_column {
  "column name"
  address
  "column name"
  transaction_version
}

"aggregate stddev on columns"
type address_version_from_move_resources_stddev_fields {
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type address_version_from_move_resources_stddev_pop_fields {
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type address_version_from_move_resources_stddev_samp_fields {
  transaction_version: Float
}

"Streaming cursor of the table \"address_version_from_move_resources\""
input address_version_from_move_resources_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: address_version_from_move_resources_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input address_version_from_move_resources_stream_cursor_value_input {
  address: String
  transaction_version: bigint
}

"aggregate sum on columns"
type address_version_from_move_resources_sum_fields {
  transaction_version: bigint
}

"aggregate var_pop on columns"
type address_version_from_move_resources_var_pop_fields {
  transaction_version: Float
}

"aggregate var_samp on columns"
type address_version_from_move_resources_var_samp_fields {
  transaction_version: Float
}

"aggregate variance on columns"
type address_version_from_move_resources_variance_fields {
  transaction_version: Float
}

scalar bigint

"Boolean expression to compare columns of type \"bigint\". All fields are combined with logical 'AND'."
input bigint_comparison_exp {
  _eq: bigint
  _gt: bigint
  _gte: bigint
  _in: [bigint!]
  _is_null: Boolean
  _lt: bigint
  _lte: bigint
  _neq: bigint
  _nin: [bigint!]
}

"columns and relationships of \"block_metadata_transactions\""
type block_metadata_transactions {
  block_height: bigint!
  epoch: bigint!
  failed_proposer_indices("JSON select path" path: String): jsonb
  id: String!
  previous_block_votes_bitvec("JSON select path" path: String): jsonb
  proposer: String!
  round: bigint!
  timestamp: timestamp!
  version: bigint!
}

"Boolean expression to filter rows from the table \"block_metadata_transactions\". All fields are combined with a logical 'AND'."
input block_metadata_transactions_bool_exp {
  _and: [block_metadata_transactions_bool_exp!]
  _not: block_metadata_transactions_bool_exp
  _or: [block_metadata_transactions_bool_exp!]
  block_height: bigint_comparison_exp
  epoch: bigint_comparison_exp
  failed_proposer_indices: jsonb_comparison_exp
  id: String_comparison_exp
  previous_block_votes_bitvec: jsonb_comparison_exp
  proposer: String_comparison_exp
  round: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  version: bigint_comparison_exp
}

"Ordering options when selecting data from \"block_metadata_transactions\"."
input block_metadata_transactions_order_by {
  block_height: order_by
  epoch: order_by
  failed_proposer_indices: order_by
  id: order_by
  previous_block_votes_bitvec: order_by
  proposer: order_by
  round: order_by
  timestamp: order_by
  version: order_by
}

"select columns of table \"block_metadata_transactions\""
enum block_metadata_transactions_select_column {
  "column name"
  block_height
  "column name"
  epoch
  "column name"
  failed_proposer_indices
  "column name"
  id
  "column name"
  previous_block_votes_bitvec
  "column name"
  proposer
  "column name"
  round
  "column name"
  timestamp
  "column name"
  version
}

"Streaming cursor of the table \"block_metadata_transactions\""
input block_metadata_transactions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: block_metadata_transactions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input block_metadata_transactions_stream_cursor_value_input {
  block_height: bigint
  epoch: bigint
  failed_proposer_indices: jsonb
  id: String
  previous_block_votes_bitvec: jsonb
  proposer: String
  round: bigint
  timestamp: timestamp
  version: bigint
}

"columns and relationships of \"legacy_migration_v1.coin_activities\""
type coin_activities {
  activity_type: String
  amount: numeric
  "An array relationship"
  aptos_names("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  aptos_names_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  block_height: bigint
  "An object relationship"
  coin_info: coin_infos
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"aggregated selection of \"legacy_migration_v1.coin_activities\""
type coin_activities_aggregate {
  aggregate: coin_activities_aggregate_fields
  nodes: [coin_activities!]!
}

input coin_activities_aggregate_bool_exp {
  bool_and: coin_activities_aggregate_bool_exp_bool_and
  bool_or: coin_activities_aggregate_bool_exp_bool_or
  count: coin_activities_aggregate_bool_exp_count
}

input coin_activities_aggregate_bool_exp_bool_and {
  arguments: coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input coin_activities_aggregate_bool_exp_bool_or {
  arguments: coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Boolean_comparison_exp!
}

input coin_activities_aggregate_bool_exp_count {
  arguments: [coin_activities_select_column!]
  distinct: Boolean
  filter: coin_activities_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"legacy_migration_v1.coin_activities\""
type coin_activities_aggregate_fields {
  avg: coin_activities_avg_fields
  count(columns: [coin_activities_select_column!] distinct: Boolean): Int!
  max: coin_activities_max_fields
  min: coin_activities_min_fields
  stddev: coin_activities_stddev_fields
  stddev_pop: coin_activities_stddev_pop_fields
  stddev_samp: coin_activities_stddev_samp_fields
  sum: coin_activities_sum_fields
  var_pop: coin_activities_var_pop_fields
  var_samp: coin_activities_var_samp_fields
  variance: coin_activities_variance_fields
}

"order by aggregate values of table \"legacy_migration_v1.coin_activities\""
input coin_activities_aggregate_order_by {
  avg: coin_activities_avg_order_by
  count: order_by
  max: coin_activities_max_order_by
  min: coin_activities_min_order_by
  stddev: coin_activities_stddev_order_by
  stddev_pop: coin_activities_stddev_pop_order_by
  stddev_samp: coin_activities_stddev_samp_order_by
  sum: coin_activities_sum_order_by
  var_pop: coin_activities_var_pop_order_by
  var_samp: coin_activities_var_samp_order_by
  variance: coin_activities_variance_order_by
}

"aggregate avg on columns"
type coin_activities_avg_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by avg() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_avg_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.coin_activities\". All fields are combined with a logical 'AND'."
input coin_activities_bool_exp {
  _and: [coin_activities_bool_exp!]
  _not: coin_activities_bool_exp
  _or: [coin_activities_bool_exp!]
  activity_type: String_comparison_exp
  amount: numeric_comparison_exp
  aptos_names: current_aptos_names_bool_exp
  aptos_names_aggregate: current_aptos_names_aggregate_bool_exp
  block_height: bigint_comparison_exp
  coin_info: coin_infos_bool_exp
  coin_type: String_comparison_exp
  entry_function_id_str: String_comparison_exp
  event_account_address: String_comparison_exp
  event_creation_number: Int_comparison_exp
  event_index: bigint_comparison_exp
  event_sequence_number: Int_comparison_exp
  is_gas_fee: Boolean_comparison_exp
  is_transaction_success: Boolean_comparison_exp
  owner_address: String_comparison_exp
  storage_refund_amount: numeric_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"aggregate max on columns"
type coin_activities_max_fields {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"order by max() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_max_order_by {
  activity_type: order_by
  amount: order_by
  block_height: order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"aggregate min on columns"
type coin_activities_min_fields {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"order by min() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_min_order_by {
  activity_type: order_by
  amount: order_by
  block_height: order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"Ordering options when selecting data from \"legacy_migration_v1.coin_activities\"."
input coin_activities_order_by {
  activity_type: order_by
  amount: order_by
  aptos_names_aggregate: current_aptos_names_aggregate_order_by
  block_height: order_by
  coin_info: coin_infos_order_by
  coin_type: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  is_gas_fee: order_by
  is_transaction_success: order_by
  owner_address: order_by
  storage_refund_amount: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.coin_activities\""
enum coin_activities_select_column {
  "column name"
  activity_type
  "column name"
  amount
  "column name"
  block_height
  "column name"
  coin_type
  "column name"
  entry_function_id_str
  "column name"
  event_account_address
  "column name"
  event_creation_number
  "column name"
  event_index
  "column name"
  event_sequence_number
  "column name"
  is_gas_fee
  "column name"
  is_transaction_success
  "column name"
  owner_address
  "column name"
  storage_refund_amount
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"select \"coin_activities_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"legacy_migration_v1.coin_activities\""
enum coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_gas_fee
  "column name"
  is_transaction_success
}

"select \"coin_activities_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"legacy_migration_v1.coin_activities\""
enum coin_activities_select_column_coin_activities_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_gas_fee
  "column name"
  is_transaction_success
}

"aggregate stddev on columns"
type coin_activities_stddev_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by stddev() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_stddev_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_pop on columns"
type coin_activities_stddev_pop_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by stddev_pop() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_stddev_pop_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_samp on columns"
type coin_activities_stddev_samp_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by stddev_samp() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_stddev_samp_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"Streaming cursor of the table \"coin_activities\""
input coin_activities_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: coin_activities_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input coin_activities_stream_cursor_value_input {
  activity_type: String
  amount: numeric
  block_height: bigint
  coin_type: String
  entry_function_id_str: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_refund_amount: numeric
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"aggregate sum on columns"
type coin_activities_sum_fields {
  amount: numeric
  block_height: bigint
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  storage_refund_amount: numeric
  transaction_version: bigint
}

"order by sum() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_sum_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"aggregate var_pop on columns"
type coin_activities_var_pop_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by var_pop() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_var_pop_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"aggregate var_samp on columns"
type coin_activities_var_samp_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by var_samp() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_var_samp_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"aggregate variance on columns"
type coin_activities_variance_fields {
  amount: Float
  block_height: Float
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  storage_refund_amount: Float
  transaction_version: Float
}

"order by variance() on columns of table \"legacy_migration_v1.coin_activities\""
input coin_activities_variance_order_by {
  amount: order_by
  block_height: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"columns and relationships of \"legacy_migration_v1.coin_balances\""
type coin_balances {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.coin_balances\". All fields are combined with a logical 'AND'."
input coin_balances_bool_exp {
  _and: [coin_balances_bool_exp!]
  _not: coin_balances_bool_exp
  _or: [coin_balances_bool_exp!]
  amount: numeric_comparison_exp
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  owner_address: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.coin_balances\"."
input coin_balances_order_by {
  amount: order_by
  coin_type: order_by
  coin_type_hash: order_by
  owner_address: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.coin_balances\""
enum coin_balances_select_column {
  "column name"
  amount
  "column name"
  coin_type
  "column name"
  coin_type_hash
  "column name"
  owner_address
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"Streaming cursor of the table \"coin_balances\""
input coin_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: coin_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input coin_balances_stream_cursor_value_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  owner_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"columns and relationships of \"legacy_migration_v1.coin_infos\""
type coin_infos {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.coin_infos\". All fields are combined with a logical 'AND'."
input coin_infos_bool_exp {
  _and: [coin_infos_bool_exp!]
  _not: coin_infos_bool_exp
  _or: [coin_infos_bool_exp!]
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  creator_address: String_comparison_exp
  decimals: Int_comparison_exp
  name: String_comparison_exp
  supply_aggregator_table_handle: String_comparison_exp
  supply_aggregator_table_key: String_comparison_exp
  symbol: String_comparison_exp
  transaction_created_timestamp: timestamp_comparison_exp
  transaction_version_created: bigint_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.coin_infos\"."
input coin_infos_order_by {
  coin_type: order_by
  coin_type_hash: order_by
  creator_address: order_by
  decimals: order_by
  name: order_by
  supply_aggregator_table_handle: order_by
  supply_aggregator_table_key: order_by
  symbol: order_by
  transaction_created_timestamp: order_by
  transaction_version_created: order_by
}

"select columns of table \"legacy_migration_v1.coin_infos\""
enum coin_infos_select_column {
  "column name"
  coin_type
  "column name"
  coin_type_hash
  "column name"
  creator_address
  "column name"
  decimals
  "column name"
  name
  "column name"
  supply_aggregator_table_handle
  "column name"
  supply_aggregator_table_key
  "column name"
  symbol
  "column name"
  transaction_created_timestamp
  "column name"
  transaction_version_created
}

"Streaming cursor of the table \"coin_infos\""
input coin_infos_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: coin_infos_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input coin_infos_stream_cursor_value_input {
  coin_type: String
  coin_type_hash: String
  creator_address: String
  decimals: Int
  name: String
  supply_aggregator_table_handle: String
  supply_aggregator_table_key: String
  symbol: String
  transaction_created_timestamp: timestamp
  transaction_version_created: bigint
}

"columns and relationships of \"coin_supply\""
type coin_supply {
  coin_type: String!
  coin_type_hash: String!
  supply: numeric!
  transaction_epoch: bigint!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
}

"Boolean expression to filter rows from the table \"coin_supply\". All fields are combined with a logical 'AND'."
input coin_supply_bool_exp {
  _and: [coin_supply_bool_exp!]
  _not: coin_supply_bool_exp
  _or: [coin_supply_bool_exp!]
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  supply: numeric_comparison_exp
  transaction_epoch: bigint_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"Ordering options when selecting data from \"coin_supply\"."
input coin_supply_order_by {
  coin_type: order_by
  coin_type_hash: order_by
  supply: order_by
  transaction_epoch: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"coin_supply\""
enum coin_supply_select_column {
  "column name"
  coin_type
  "column name"
  coin_type_hash
  "column name"
  supply
  "column name"
  transaction_epoch
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"Streaming cursor of the table \"coin_supply\""
input coin_supply_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: coin_supply_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input coin_supply_stream_cursor_value_input {
  coin_type: String
  coin_type_hash: String
  supply: numeric
  transaction_epoch: bigint
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"columns and relationships of \"legacy_migration_v1.collection_datas\""
type collection_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.collection_datas\". All fields are combined with a logical 'AND'."
input collection_datas_bool_exp {
  _and: [collection_datas_bool_exp!]
  _not: collection_datas_bool_exp
  _or: [collection_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  supply: numeric_comparison_exp
  table_handle: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.collection_datas\"."
input collection_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  description: order_by
  description_mutable: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  supply: order_by
  table_handle: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  uri_mutable: order_by
}

"select columns of table \"legacy_migration_v1.collection_datas\""
enum collection_datas_select_column {
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  description
  "column name"
  description_mutable
  "column name"
  maximum
  "column name"
  maximum_mutable
  "column name"
  metadata_uri
  "column name"
  supply
  "column name"
  table_handle
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  uri_mutable
}

"Streaming cursor of the table \"collection_datas\""
input collection_datas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: collection_datas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input collection_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"columns and relationships of \"legacy_migration_v1.current_ans_lookup\""
type current_ans_lookup {
  "An array relationship"
  all_token_ownerships("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): [current_token_ownerships!]!
  "An aggregate relationship"
  all_token_ownerships_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): current_token_ownerships_aggregate!
  domain: String
  expiration_timestamp: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.current_ans_lookup\". All fields are combined with a logical 'AND'."
input current_ans_lookup_bool_exp {
  _and: [current_ans_lookup_bool_exp!]
  _not: current_ans_lookup_bool_exp
  _or: [current_ans_lookup_bool_exp!]
  all_token_ownerships: current_token_ownerships_bool_exp
  all_token_ownerships_aggregate: current_token_ownerships_aggregate_bool_exp
  domain: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  token_name: String_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.current_ans_lookup\"."
input current_ans_lookup_order_by {
  all_token_ownerships_aggregate: current_token_ownerships_aggregate_order_by
  domain: order_by
  expiration_timestamp: order_by
  is_deleted: order_by
  last_transaction_version: order_by
  registered_address: order_by
  subdomain: order_by
  token_name: order_by
}

"select columns of table \"legacy_migration_v1.current_ans_lookup\""
enum current_ans_lookup_select_column {
  "column name"
  domain
  "column name"
  expiration_timestamp
  "column name"
  is_deleted
  "column name"
  last_transaction_version
  "column name"
  registered_address
  "column name"
  subdomain
  "column name"
  token_name
}

"Streaming cursor of the table \"current_ans_lookup\""
input current_ans_lookup_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_ans_lookup_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_ans_lookup_stream_cursor_value_input {
  domain: String
  expiration_timestamp: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
}

"columns and relationships of \"current_ans_lookup_v2\""
type current_ans_lookup_v2 {
  domain: String!
  expiration_timestamp: timestamp!
  is_deleted: Boolean!
  last_transaction_version: bigint!
  registered_address: String
  subdomain: String!
  token_name: String
  token_standard: String!
}

"Boolean expression to filter rows from the table \"current_ans_lookup_v2\". All fields are combined with a logical 'AND'."
input current_ans_lookup_v2_bool_exp {
  _and: [current_ans_lookup_v2_bool_exp!]
  _not: current_ans_lookup_v2_bool_exp
  _or: [current_ans_lookup_v2_bool_exp!]
  domain: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  token_name: String_comparison_exp
  token_standard: String_comparison_exp
}

"Ordering options when selecting data from \"current_ans_lookup_v2\"."
input current_ans_lookup_v2_order_by {
  domain: order_by
  expiration_timestamp: order_by
  is_deleted: order_by
  last_transaction_version: order_by
  registered_address: order_by
  subdomain: order_by
  token_name: order_by
  token_standard: order_by
}

"select columns of table \"current_ans_lookup_v2\""
enum current_ans_lookup_v2_select_column {
  "column name"
  domain
  "column name"
  expiration_timestamp
  "column name"
  is_deleted
  "column name"
  last_transaction_version
  "column name"
  registered_address
  "column name"
  subdomain
  "column name"
  token_name
  "column name"
  token_standard
}

"Streaming cursor of the table \"current_ans_lookup_v2\""
input current_ans_lookup_v2_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_ans_lookup_v2_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_ans_lookup_v2_stream_cursor_value_input {
  domain: String
  expiration_timestamp: timestamp
  is_deleted: Boolean
  last_transaction_version: bigint
  registered_address: String
  subdomain: String
  token_name: String
  token_standard: String
}

"columns and relationships of \"current_aptos_names\""
type current_aptos_names {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  is_active: Boolean
  "An object relationship"
  is_domain_owner: current_aptos_names
  is_primary: Boolean
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"aggregated selection of \"current_aptos_names\""
type current_aptos_names_aggregate {
  aggregate: current_aptos_names_aggregate_fields
  nodes: [current_aptos_names!]!
}

input current_aptos_names_aggregate_bool_exp {
  bool_and: current_aptos_names_aggregate_bool_exp_bool_and
  bool_or: current_aptos_names_aggregate_bool_exp_bool_or
  count: current_aptos_names_aggregate_bool_exp_count
}

input current_aptos_names_aggregate_bool_exp_bool_and {
  arguments: current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_aptos_names_aggregate_bool_exp_bool_or {
  arguments: current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_aptos_names_aggregate_bool_exp_count {
  arguments: [current_aptos_names_select_column!]
  distinct: Boolean
  filter: current_aptos_names_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"current_aptos_names\""
type current_aptos_names_aggregate_fields {
  avg: current_aptos_names_avg_fields
  count(columns: [current_aptos_names_select_column!] distinct: Boolean): Int!
  max: current_aptos_names_max_fields
  min: current_aptos_names_min_fields
  stddev: current_aptos_names_stddev_fields
  stddev_pop: current_aptos_names_stddev_pop_fields
  stddev_samp: current_aptos_names_stddev_samp_fields
  sum: current_aptos_names_sum_fields
  var_pop: current_aptos_names_var_pop_fields
  var_samp: current_aptos_names_var_samp_fields
  variance: current_aptos_names_variance_fields
}

"order by aggregate values of table \"current_aptos_names\""
input current_aptos_names_aggregate_order_by {
  avg: current_aptos_names_avg_order_by
  count: order_by
  max: current_aptos_names_max_order_by
  min: current_aptos_names_min_order_by
  stddev: current_aptos_names_stddev_order_by
  stddev_pop: current_aptos_names_stddev_pop_order_by
  stddev_samp: current_aptos_names_stddev_samp_order_by
  sum: current_aptos_names_sum_order_by
  var_pop: current_aptos_names_var_pop_order_by
  var_samp: current_aptos_names_var_samp_order_by
  variance: current_aptos_names_variance_order_by
}

"aggregate avg on columns"
type current_aptos_names_avg_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by avg() on columns of table \"current_aptos_names\""
input current_aptos_names_avg_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"Boolean expression to filter rows from the table \"current_aptos_names\". All fields are combined with a logical 'AND'."
input current_aptos_names_bool_exp {
  _and: [current_aptos_names_bool_exp!]
  _not: current_aptos_names_bool_exp
  _or: [current_aptos_names_bool_exp!]
  domain: String_comparison_exp
  domain_expiration_timestamp: timestamp_comparison_exp
  domain_with_suffix: String_comparison_exp
  expiration_timestamp: timestamp_comparison_exp
  is_active: Boolean_comparison_exp
  is_domain_owner: current_aptos_names_bool_exp
  is_primary: Boolean_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
  registered_address: String_comparison_exp
  subdomain: String_comparison_exp
  subdomain_expiration_policy: bigint_comparison_exp
  token_name: String_comparison_exp
  token_standard: String_comparison_exp
}

"aggregate max on columns"
type current_aptos_names_max_fields {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"order by max() on columns of table \"current_aptos_names\""
input current_aptos_names_max_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_name: order_by
  token_standard: order_by
}

"aggregate min on columns"
type current_aptos_names_min_fields {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"order by min() on columns of table \"current_aptos_names\""
input current_aptos_names_min_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_name: order_by
  token_standard: order_by
}

"Ordering options when selecting data from \"current_aptos_names\"."
input current_aptos_names_order_by {
  domain: order_by
  domain_expiration_timestamp: order_by
  domain_with_suffix: order_by
  expiration_timestamp: order_by
  is_active: order_by
  is_domain_owner: current_aptos_names_order_by
  is_primary: order_by
  last_transaction_version: order_by
  owner_address: order_by
  registered_address: order_by
  subdomain: order_by
  subdomain_expiration_policy: order_by
  token_name: order_by
  token_standard: order_by
}

"select columns of table \"current_aptos_names\""
enum current_aptos_names_select_column {
  "column name"
  domain
  "column name"
  domain_expiration_timestamp
  "column name"
  domain_with_suffix
  "column name"
  expiration_timestamp
  "column name"
  is_active
  "column name"
  is_primary
  "column name"
  last_transaction_version
  "column name"
  owner_address
  "column name"
  registered_address
  "column name"
  subdomain
  "column name"
  subdomain_expiration_policy
  "column name"
  token_name
  "column name"
  token_standard
}

"select \"current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_aptos_names\""
enum current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_active
  "column name"
  is_primary
}

"select \"current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_aptos_names\""
enum current_aptos_names_select_column_current_aptos_names_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_active
  "column name"
  is_primary
}

"aggregate stddev on columns"
type current_aptos_names_stddev_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by stddev() on columns of table \"current_aptos_names\""
input current_aptos_names_stddev_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"aggregate stddev_pop on columns"
type current_aptos_names_stddev_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by stddev_pop() on columns of table \"current_aptos_names\""
input current_aptos_names_stddev_pop_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"aggregate stddev_samp on columns"
type current_aptos_names_stddev_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by stddev_samp() on columns of table \"current_aptos_names\""
input current_aptos_names_stddev_samp_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"Streaming cursor of the table \"current_aptos_names\""
input current_aptos_names_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_aptos_names_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_aptos_names_stream_cursor_value_input {
  domain: String
  domain_expiration_timestamp: timestamp
  domain_with_suffix: String
  expiration_timestamp: timestamp
  is_active: Boolean
  is_primary: Boolean
  last_transaction_version: bigint
  owner_address: String
  registered_address: String
  subdomain: String
  subdomain_expiration_policy: bigint
  token_name: String
  token_standard: String
}

"aggregate sum on columns"
type current_aptos_names_sum_fields {
  last_transaction_version: bigint
  subdomain_expiration_policy: bigint
}

"order by sum() on columns of table \"current_aptos_names\""
input current_aptos_names_sum_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"aggregate var_pop on columns"
type current_aptos_names_var_pop_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by var_pop() on columns of table \"current_aptos_names\""
input current_aptos_names_var_pop_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"aggregate var_samp on columns"
type current_aptos_names_var_samp_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by var_samp() on columns of table \"current_aptos_names\""
input current_aptos_names_var_samp_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"aggregate variance on columns"
type current_aptos_names_variance_fields {
  last_transaction_version: Float
  subdomain_expiration_policy: Float
}

"order by variance() on columns of table \"current_aptos_names\""
input current_aptos_names_variance_order_by {
  last_transaction_version: order_by
  subdomain_expiration_policy: order_by
}

"columns and relationships of \"legacy_migration_v1.current_coin_balances\""
type current_coin_balances {
  amount: numeric
  "An object relationship"
  coin_info: coin_infos
  coin_type: String
  coin_type_hash: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.current_coin_balances\". All fields are combined with a logical 'AND'."
input current_coin_balances_bool_exp {
  _and: [current_coin_balances_bool_exp!]
  _not: current_coin_balances_bool_exp
  _or: [current_coin_balances_bool_exp!]
  amount: numeric_comparison_exp
  coin_info: coin_infos_bool_exp
  coin_type: String_comparison_exp
  coin_type_hash: String_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.current_coin_balances\"."
input current_coin_balances_order_by {
  amount: order_by
  coin_info: coin_infos_order_by
  coin_type: order_by
  coin_type_hash: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
}

"select columns of table \"legacy_migration_v1.current_coin_balances\""
enum current_coin_balances_select_column {
  "column name"
  amount
  "column name"
  coin_type
  "column name"
  coin_type_hash
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  owner_address
}

"Streaming cursor of the table \"current_coin_balances\""
input current_coin_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_coin_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_coin_balances_stream_cursor_value_input {
  amount: numeric
  coin_type: String
  coin_type_hash: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
}

"columns and relationships of \"legacy_migration_v1.current_collection_datas\""
type current_collection_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.current_collection_datas\". All fields are combined with a logical 'AND'."
input current_collection_datas_bool_exp {
  _and: [current_collection_datas_bool_exp!]
  _not: current_collection_datas_bool_exp
  _or: [current_collection_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  supply: numeric_comparison_exp
  table_handle: String_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.current_collection_datas\"."
input current_collection_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  description: order_by
  description_mutable: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  supply: order_by
  table_handle: order_by
  uri_mutable: order_by
}

"select columns of table \"legacy_migration_v1.current_collection_datas\""
enum current_collection_datas_select_column {
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  description
  "column name"
  description_mutable
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  maximum
  "column name"
  maximum_mutable
  "column name"
  metadata_uri
  "column name"
  supply
  "column name"
  table_handle
  "column name"
  uri_mutable
}

"Streaming cursor of the table \"current_collection_datas\""
input current_collection_datas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_collection_datas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_collection_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  description: String
  description_mutable: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  supply: numeric
  table_handle: String
  uri_mutable: Boolean
}

"columns and relationships of \"current_collection_ownership_v2_view\""
type current_collection_ownership_v2_view {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  "An object relationship"
  current_collection: current_collections_v2
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"aggregated selection of \"current_collection_ownership_v2_view\""
type current_collection_ownership_v2_view_aggregate {
  aggregate: current_collection_ownership_v2_view_aggregate_fields
  nodes: [current_collection_ownership_v2_view!]!
}

"aggregate fields of \"current_collection_ownership_v2_view\""
type current_collection_ownership_v2_view_aggregate_fields {
  avg: current_collection_ownership_v2_view_avg_fields
  count(columns: [current_collection_ownership_v2_view_select_column!] distinct: Boolean): Int!
  max: current_collection_ownership_v2_view_max_fields
  min: current_collection_ownership_v2_view_min_fields
  stddev: current_collection_ownership_v2_view_stddev_fields
  stddev_pop: current_collection_ownership_v2_view_stddev_pop_fields
  stddev_samp: current_collection_ownership_v2_view_stddev_samp_fields
  sum: current_collection_ownership_v2_view_sum_fields
  var_pop: current_collection_ownership_v2_view_var_pop_fields
  var_samp: current_collection_ownership_v2_view_var_samp_fields
  variance: current_collection_ownership_v2_view_variance_fields
}

"aggregate avg on columns"
type current_collection_ownership_v2_view_avg_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"Boolean expression to filter rows from the table \"current_collection_ownership_v2_view\". All fields are combined with a logical 'AND'."
input current_collection_ownership_v2_view_bool_exp {
  _and: [current_collection_ownership_v2_view_bool_exp!]
  _not: current_collection_ownership_v2_view_bool_exp
  _or: [current_collection_ownership_v2_view_bool_exp!]
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  collection_uri: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection: current_collections_v2_bool_exp
  distinct_tokens: bigint_comparison_exp
  last_transaction_version: bigint_comparison_exp
  owner_address: String_comparison_exp
  single_token_uri: String_comparison_exp
}

"aggregate max on columns"
type current_collection_ownership_v2_view_max_fields {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"aggregate min on columns"
type current_collection_ownership_v2_view_min_fields {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"Ordering options when selecting data from \"current_collection_ownership_v2_view\"."
input current_collection_ownership_v2_view_order_by {
  collection_id: order_by
  collection_name: order_by
  collection_uri: order_by
  creator_address: order_by
  current_collection: current_collections_v2_order_by
  distinct_tokens: order_by
  last_transaction_version: order_by
  owner_address: order_by
  single_token_uri: order_by
}

"select columns of table \"current_collection_ownership_v2_view\""
enum current_collection_ownership_v2_view_select_column {
  "column name"
  collection_id
  "column name"
  collection_name
  "column name"
  collection_uri
  "column name"
  creator_address
  "column name"
  distinct_tokens
  "column name"
  last_transaction_version
  "column name"
  owner_address
  "column name"
  single_token_uri
}

"aggregate stddev on columns"
type current_collection_ownership_v2_view_stddev_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"aggregate stddev_pop on columns"
type current_collection_ownership_v2_view_stddev_pop_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"aggregate stddev_samp on columns"
type current_collection_ownership_v2_view_stddev_samp_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"Streaming cursor of the table \"current_collection_ownership_v2_view\""
input current_collection_ownership_v2_view_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_collection_ownership_v2_view_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_collection_ownership_v2_view_stream_cursor_value_input {
  collection_id: String
  collection_name: String
  collection_uri: String
  creator_address: String
  distinct_tokens: bigint
  last_transaction_version: bigint
  owner_address: String
  single_token_uri: String
}

"aggregate sum on columns"
type current_collection_ownership_v2_view_sum_fields {
  distinct_tokens: bigint
  last_transaction_version: bigint
}

"aggregate var_pop on columns"
type current_collection_ownership_v2_view_var_pop_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"aggregate var_samp on columns"
type current_collection_ownership_v2_view_var_samp_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"aggregate variance on columns"
type current_collection_ownership_v2_view_variance_fields {
  distinct_tokens: Float
  last_transaction_version: Float
}

"columns and relationships of \"current_collections_v2\""
type current_collections_v2 {
  "An object relationship"
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris
  collection_id: String!
  collection_name: String!
  collection_properties("JSON select path" path: String): jsonb
  creator_address: String!
  current_supply: numeric!
  description: String!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String!
  total_minted_v2: numeric
  uri: String!
}

"Boolean expression to filter rows from the table \"current_collections_v2\". All fields are combined with a logical 'AND'."
input current_collections_v2_bool_exp {
  _and: [current_collections_v2_bool_exp!]
  _not: current_collections_v2_bool_exp
  _or: [current_collections_v2_bool_exp!]
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_bool_exp
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  collection_properties: jsonb_comparison_exp
  creator_address: String_comparison_exp
  current_supply: numeric_comparison_exp
  description: String_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  max_supply: numeric_comparison_exp
  mutable_description: Boolean_comparison_exp
  mutable_uri: Boolean_comparison_exp
  table_handle_v1: String_comparison_exp
  token_standard: String_comparison_exp
  total_minted_v2: numeric_comparison_exp
  uri: String_comparison_exp
}

"Ordering options when selecting data from \"current_collections_v2\"."
input current_collections_v2_order_by {
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_order_by
  collection_id: order_by
  collection_name: order_by
  collection_properties: order_by
  creator_address: order_by
  current_supply: order_by
  description: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  max_supply: order_by
  mutable_description: order_by
  mutable_uri: order_by
  table_handle_v1: order_by
  token_standard: order_by
  total_minted_v2: order_by
  uri: order_by
}

"select columns of table \"current_collections_v2\""
enum current_collections_v2_select_column {
  "column name"
  collection_id
  "column name"
  collection_name
  "column name"
  collection_properties
  "column name"
  creator_address
  "column name"
  current_supply
  "column name"
  description
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  max_supply
  "column name"
  mutable_description
  "column name"
  mutable_uri
  "column name"
  table_handle_v1
  "column name"
  token_standard
  "column name"
  total_minted_v2
  "column name"
  uri
}

"Streaming cursor of the table \"current_collections_v2\""
input current_collections_v2_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_collections_v2_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_collections_v2_stream_cursor_value_input {
  collection_id: String
  collection_name: String
  collection_properties: jsonb
  creator_address: String
  current_supply: numeric
  description: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  max_supply: numeric
  mutable_description: Boolean
  mutable_uri: Boolean
  table_handle_v1: String
  token_standard: String
  total_minted_v2: numeric
  uri: String
}

"columns and relationships of \"current_delegated_staking_pool_balances\""
type current_delegated_staking_pool_balances {
  active_table_handle: String!
  inactive_table_handle: String!
  last_transaction_version: bigint!
  operator_commission_percentage: numeric!
  staking_pool_address: String!
  total_coins: numeric!
  total_shares: numeric!
}

"Boolean expression to filter rows from the table \"current_delegated_staking_pool_balances\". All fields are combined with a logical 'AND'."
input current_delegated_staking_pool_balances_bool_exp {
  _and: [current_delegated_staking_pool_balances_bool_exp!]
  _not: current_delegated_staking_pool_balances_bool_exp
  _or: [current_delegated_staking_pool_balances_bool_exp!]
  active_table_handle: String_comparison_exp
  inactive_table_handle: String_comparison_exp
  last_transaction_version: bigint_comparison_exp
  operator_commission_percentage: numeric_comparison_exp
  staking_pool_address: String_comparison_exp
  total_coins: numeric_comparison_exp
  total_shares: numeric_comparison_exp
}

"Ordering options when selecting data from \"current_delegated_staking_pool_balances\"."
input current_delegated_staking_pool_balances_order_by {
  active_table_handle: order_by
  inactive_table_handle: order_by
  last_transaction_version: order_by
  operator_commission_percentage: order_by
  staking_pool_address: order_by
  total_coins: order_by
  total_shares: order_by
}

"select columns of table \"current_delegated_staking_pool_balances\""
enum current_delegated_staking_pool_balances_select_column {
  "column name"
  active_table_handle
  "column name"
  inactive_table_handle
  "column name"
  last_transaction_version
  "column name"
  operator_commission_percentage
  "column name"
  staking_pool_address
  "column name"
  total_coins
  "column name"
  total_shares
}

"Streaming cursor of the table \"current_delegated_staking_pool_balances\""
input current_delegated_staking_pool_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_delegated_staking_pool_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_delegated_staking_pool_balances_stream_cursor_value_input {
  active_table_handle: String
  inactive_table_handle: String
  last_transaction_version: bigint
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
}

"columns and relationships of \"current_delegated_voter\""
type current_delegated_voter {
  delegation_pool_address: String!
  delegator_address: String!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  pending_voter: String
  table_handle: String
  voter: String
}

"Boolean expression to filter rows from the table \"current_delegated_voter\". All fields are combined with a logical 'AND'."
input current_delegated_voter_bool_exp {
  _and: [current_delegated_voter_bool_exp!]
  _not: current_delegated_voter_bool_exp
  _or: [current_delegated_voter_bool_exp!]
  delegation_pool_address: String_comparison_exp
  delegator_address: String_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  pending_voter: String_comparison_exp
  table_handle: String_comparison_exp
  voter: String_comparison_exp
}

"Ordering options when selecting data from \"current_delegated_voter\"."
input current_delegated_voter_order_by {
  delegation_pool_address: order_by
  delegator_address: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  pending_voter: order_by
  table_handle: order_by
  voter: order_by
}

"select columns of table \"current_delegated_voter\""
enum current_delegated_voter_select_column {
  "column name"
  delegation_pool_address
  "column name"
  delegator_address
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  pending_voter
  "column name"
  table_handle
  "column name"
  voter
}

"Streaming cursor of the table \"current_delegated_voter\""
input current_delegated_voter_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_delegated_voter_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_delegated_voter_stream_cursor_value_input {
  delegation_pool_address: String
  delegator_address: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  pending_voter: String
  table_handle: String
  voter: String
}

"columns and relationships of \"current_delegator_balances\""
type current_delegator_balances {
  "An object relationship"
  current_pool_balance: current_delegated_staking_pool_balances
  delegator_address: String!
  last_transaction_version: bigint!
  parent_table_handle: String!
  pool_address: String!
  pool_type: String!
  shares: numeric!
  "An object relationship"
  staking_pool_metadata: current_staking_pool_voter
  table_handle: String!
}

"Boolean expression to filter rows from the table \"current_delegator_balances\". All fields are combined with a logical 'AND'."
input current_delegator_balances_bool_exp {
  _and: [current_delegator_balances_bool_exp!]
  _not: current_delegator_balances_bool_exp
  _or: [current_delegator_balances_bool_exp!]
  current_pool_balance: current_delegated_staking_pool_balances_bool_exp
  delegator_address: String_comparison_exp
  last_transaction_version: bigint_comparison_exp
  parent_table_handle: String_comparison_exp
  pool_address: String_comparison_exp
  pool_type: String_comparison_exp
  shares: numeric_comparison_exp
  staking_pool_metadata: current_staking_pool_voter_bool_exp
  table_handle: String_comparison_exp
}

"Ordering options when selecting data from \"current_delegator_balances\"."
input current_delegator_balances_order_by {
  current_pool_balance: current_delegated_staking_pool_balances_order_by
  delegator_address: order_by
  last_transaction_version: order_by
  parent_table_handle: order_by
  pool_address: order_by
  pool_type: order_by
  shares: order_by
  staking_pool_metadata: current_staking_pool_voter_order_by
  table_handle: order_by
}

"select columns of table \"current_delegator_balances\""
enum current_delegator_balances_select_column {
  "column name"
  delegator_address
  "column name"
  last_transaction_version
  "column name"
  parent_table_handle
  "column name"
  pool_address
  "column name"
  pool_type
  "column name"
  shares
  "column name"
  table_handle
}

"Streaming cursor of the table \"current_delegator_balances\""
input current_delegator_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_delegator_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_delegator_balances_stream_cursor_value_input {
  delegator_address: String
  last_transaction_version: bigint
  parent_table_handle: String
  pool_address: String
  pool_type: String
  shares: numeric
  table_handle: String
}

"columns and relationships of \"current_fungible_asset_balances\""
type current_fungible_asset_balances {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  is_frozen: Boolean!
  is_primary: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  "An object relationship"
  metadata: fungible_asset_metadata
  owner_address: String!
  storage_id: String!
  token_standard: String
}

"aggregated selection of \"current_fungible_asset_balances\""
type current_fungible_asset_balances_aggregate {
  aggregate: current_fungible_asset_balances_aggregate_fields
  nodes: [current_fungible_asset_balances!]!
}

"aggregate fields of \"current_fungible_asset_balances\""
type current_fungible_asset_balances_aggregate_fields {
  avg: current_fungible_asset_balances_avg_fields
  count(columns: [current_fungible_asset_balances_select_column!] distinct: Boolean): Int!
  max: current_fungible_asset_balances_max_fields
  min: current_fungible_asset_balances_min_fields
  stddev: current_fungible_asset_balances_stddev_fields
  stddev_pop: current_fungible_asset_balances_stddev_pop_fields
  stddev_samp: current_fungible_asset_balances_stddev_samp_fields
  sum: current_fungible_asset_balances_sum_fields
  var_pop: current_fungible_asset_balances_var_pop_fields
  var_samp: current_fungible_asset_balances_var_samp_fields
  variance: current_fungible_asset_balances_variance_fields
}

"aggregate avg on columns"
type current_fungible_asset_balances_avg_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"Boolean expression to filter rows from the table \"current_fungible_asset_balances\". All fields are combined with a logical 'AND'."
input current_fungible_asset_balances_bool_exp {
  _and: [current_fungible_asset_balances_bool_exp!]
  _not: current_fungible_asset_balances_bool_exp
  _or: [current_fungible_asset_balances_bool_exp!]
  amount: numeric_comparison_exp
  amount_v1: numeric_comparison_exp
  amount_v2: numeric_comparison_exp
  asset_type: String_comparison_exp
  asset_type_v1: String_comparison_exp
  asset_type_v2: String_comparison_exp
  is_frozen: Boolean_comparison_exp
  is_primary: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_timestamp_v1: timestamp_comparison_exp
  last_transaction_timestamp_v2: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  last_transaction_version_v1: bigint_comparison_exp
  last_transaction_version_v2: bigint_comparison_exp
  metadata: fungible_asset_metadata_bool_exp
  owner_address: String_comparison_exp
  storage_id: String_comparison_exp
  token_standard: String_comparison_exp
}

"aggregate max on columns"
type current_fungible_asset_balances_max_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"aggregate min on columns"
type current_fungible_asset_balances_min_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"Ordering options when selecting data from \"current_fungible_asset_balances\"."
input current_fungible_asset_balances_order_by {
  amount: order_by
  amount_v1: order_by
  amount_v2: order_by
  asset_type: order_by
  asset_type_v1: order_by
  asset_type_v2: order_by
  is_frozen: order_by
  is_primary: order_by
  last_transaction_timestamp: order_by
  last_transaction_timestamp_v1: order_by
  last_transaction_timestamp_v2: order_by
  last_transaction_version: order_by
  last_transaction_version_v1: order_by
  last_transaction_version_v2: order_by
  metadata: fungible_asset_metadata_order_by
  owner_address: order_by
  storage_id: order_by
  token_standard: order_by
}

"select columns of table \"current_fungible_asset_balances\""
enum current_fungible_asset_balances_select_column {
  "column name"
  amount
  "column name"
  amount_v1
  "column name"
  amount_v2
  "column name"
  asset_type
  "column name"
  asset_type_v1
  "column name"
  asset_type_v2
  "column name"
  is_frozen
  "column name"
  is_primary
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_timestamp_v1
  "column name"
  last_transaction_timestamp_v2
  "column name"
  last_transaction_version
  "column name"
  last_transaction_version_v1
  "column name"
  last_transaction_version_v2
  "column name"
  owner_address
  "column name"
  storage_id
  "column name"
  token_standard
}

"aggregate stddev on columns"
type current_fungible_asset_balances_stddev_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"aggregate stddev_pop on columns"
type current_fungible_asset_balances_stddev_pop_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"aggregate stddev_samp on columns"
type current_fungible_asset_balances_stddev_samp_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"Streaming cursor of the table \"current_fungible_asset_balances\""
input current_fungible_asset_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_fungible_asset_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_fungible_asset_balances_stream_cursor_value_input {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  asset_type: String
  asset_type_v1: String
  asset_type_v2: String
  is_frozen: Boolean
  is_primary: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_timestamp_v1: timestamp
  last_transaction_timestamp_v2: timestamp
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
  owner_address: String
  storage_id: String
  token_standard: String
}

"aggregate sum on columns"
type current_fungible_asset_balances_sum_fields {
  amount: numeric
  amount_v1: numeric
  amount_v2: numeric
  last_transaction_version: bigint
  last_transaction_version_v1: bigint
  last_transaction_version_v2: bigint
}

"aggregate var_pop on columns"
type current_fungible_asset_balances_var_pop_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"aggregate var_samp on columns"
type current_fungible_asset_balances_var_samp_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"aggregate variance on columns"
type current_fungible_asset_balances_variance_fields {
  amount: Float
  amount_v1: Float
  amount_v2: Float
  last_transaction_version: Float
  last_transaction_version_v1: Float
  last_transaction_version_v2: Float
}

"columns and relationships of \"current_objects\""
type current_objects {
  allow_ungated_transfer: Boolean!
  is_deleted: Boolean!
  last_guid_creation_num: numeric!
  last_transaction_version: bigint!
  object_address: String!
  owner_address: String!
  state_key_hash: String!
}

"Boolean expression to filter rows from the table \"current_objects\". All fields are combined with a logical 'AND'."
input current_objects_bool_exp {
  _and: [current_objects_bool_exp!]
  _not: current_objects_bool_exp
  _or: [current_objects_bool_exp!]
  allow_ungated_transfer: Boolean_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_guid_creation_num: numeric_comparison_exp
  last_transaction_version: bigint_comparison_exp
  object_address: String_comparison_exp
  owner_address: String_comparison_exp
  state_key_hash: String_comparison_exp
}

"Ordering options when selecting data from \"current_objects\"."
input current_objects_order_by {
  allow_ungated_transfer: order_by
  is_deleted: order_by
  last_guid_creation_num: order_by
  last_transaction_version: order_by
  object_address: order_by
  owner_address: order_by
  state_key_hash: order_by
}

"select columns of table \"current_objects\""
enum current_objects_select_column {
  "column name"
  allow_ungated_transfer
  "column name"
  is_deleted
  "column name"
  last_guid_creation_num
  "column name"
  last_transaction_version
  "column name"
  object_address
  "column name"
  owner_address
  "column name"
  state_key_hash
}

"Streaming cursor of the table \"current_objects\""
input current_objects_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_objects_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_objects_stream_cursor_value_input {
  allow_ungated_transfer: Boolean
  is_deleted: Boolean
  last_guid_creation_num: numeric
  last_transaction_version: bigint
  object_address: String
  owner_address: String
  state_key_hash: String
}

"columns and relationships of \"current_staking_pool_voter\""
type current_staking_pool_voter {
  last_transaction_version: bigint!
  operator_address: String!
  "An array relationship"
  operator_aptos_name("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  operator_aptos_name_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  staking_pool_address: String!
  voter_address: String!
}

"Boolean expression to filter rows from the table \"current_staking_pool_voter\". All fields are combined with a logical 'AND'."
input current_staking_pool_voter_bool_exp {
  _and: [current_staking_pool_voter_bool_exp!]
  _not: current_staking_pool_voter_bool_exp
  _or: [current_staking_pool_voter_bool_exp!]
  last_transaction_version: bigint_comparison_exp
  operator_address: String_comparison_exp
  operator_aptos_name: current_aptos_names_bool_exp
  operator_aptos_name_aggregate: current_aptos_names_aggregate_bool_exp
  staking_pool_address: String_comparison_exp
  voter_address: String_comparison_exp
}

"Ordering options when selecting data from \"current_staking_pool_voter\"."
input current_staking_pool_voter_order_by {
  last_transaction_version: order_by
  operator_address: order_by
  operator_aptos_name_aggregate: current_aptos_names_aggregate_order_by
  staking_pool_address: order_by
  voter_address: order_by
}

"select columns of table \"current_staking_pool_voter\""
enum current_staking_pool_voter_select_column {
  "column name"
  last_transaction_version
  "column name"
  operator_address
  "column name"
  staking_pool_address
  "column name"
  voter_address
}

"Streaming cursor of the table \"current_staking_pool_voter\""
input current_staking_pool_voter_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_staking_pool_voter_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_staking_pool_voter_stream_cursor_value_input {
  last_transaction_version: bigint
  operator_address: String
  staking_pool_address: String
  voter_address: String
}

"columns and relationships of \"current_table_items\""
type current_table_items {
  decoded_key("JSON select path" path: String): jsonb
  decoded_value("JSON select path" path: String): jsonb
  is_deleted: Boolean!
  key: String!
  key_hash: String!
  last_transaction_version: bigint!
  table_handle: String!
}

"Boolean expression to filter rows from the table \"current_table_items\". All fields are combined with a logical 'AND'."
input current_table_items_bool_exp {
  _and: [current_table_items_bool_exp!]
  _not: current_table_items_bool_exp
  _or: [current_table_items_bool_exp!]
  decoded_key: jsonb_comparison_exp
  decoded_value: jsonb_comparison_exp
  is_deleted: Boolean_comparison_exp
  key: String_comparison_exp
  key_hash: String_comparison_exp
  last_transaction_version: bigint_comparison_exp
  table_handle: String_comparison_exp
}

"Ordering options when selecting data from \"current_table_items\"."
input current_table_items_order_by {
  decoded_key: order_by
  decoded_value: order_by
  is_deleted: order_by
  key: order_by
  key_hash: order_by
  last_transaction_version: order_by
  table_handle: order_by
}

"select columns of table \"current_table_items\""
enum current_table_items_select_column {
  "column name"
  decoded_key
  "column name"
  decoded_value
  "column name"
  is_deleted
  "column name"
  key
  "column name"
  key_hash
  "column name"
  last_transaction_version
  "column name"
  table_handle
}

"Streaming cursor of the table \"current_table_items\""
input current_table_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_table_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_table_items_stream_cursor_value_input {
  decoded_key: jsonb
  decoded_value: jsonb
  is_deleted: Boolean
  key: String
  key_hash: String
  last_transaction_version: bigint
  table_handle: String
}

"columns and relationships of \"legacy_migration_v1.current_token_datas\""
type current_token_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  "An object relationship"
  current_collection_data: current_collection_datas
  default_properties("JSON select path" path: String): jsonb
  description: String
  description_mutable: Boolean
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
  uri_mutable: Boolean
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.current_token_datas\". All fields are combined with a logical 'AND'."
input current_token_datas_bool_exp {
  _and: [current_token_datas_bool_exp!]
  _not: current_token_datas_bool_exp
  _or: [current_token_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  default_properties: jsonb_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  largest_property_version: numeric_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  name: String_comparison_exp
  payee_address: String_comparison_exp
  properties_mutable: Boolean_comparison_exp
  royalty_mutable: Boolean_comparison_exp
  royalty_points_denominator: numeric_comparison_exp
  royalty_points_numerator: numeric_comparison_exp
  supply: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.current_token_datas\"."
input current_token_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  default_properties: order_by
  description: order_by
  description_mutable: order_by
  largest_property_version: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  name: order_by
  payee_address: order_by
  properties_mutable: order_by
  royalty_mutable: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  supply: order_by
  token_data_id_hash: order_by
  uri_mutable: order_by
}

"select columns of table \"legacy_migration_v1.current_token_datas\""
enum current_token_datas_select_column {
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  default_properties
  "column name"
  description
  "column name"
  description_mutable
  "column name"
  largest_property_version
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  maximum
  "column name"
  maximum_mutable
  "column name"
  metadata_uri
  "column name"
  name
  "column name"
  payee_address
  "column name"
  properties_mutable
  "column name"
  royalty_mutable
  "column name"
  royalty_points_denominator
  "column name"
  royalty_points_numerator
  "column name"
  supply
  "column name"
  token_data_id_hash
  "column name"
  uri_mutable
}

"Streaming cursor of the table \"current_token_datas\""
input current_token_datas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_datas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties: jsonb
  description: String
  description_mutable: Boolean
  largest_property_version: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  supply: numeric
  token_data_id_hash: String
  uri_mutable: Boolean
}

"columns and relationships of \"current_token_datas_v2\""
type current_token_datas_v2 {
  "An object relationship"
  aptos_name: current_aptos_names
  "An object relationship"
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris
  collection_id: String!
  "An object relationship"
  current_collection: current_collections_v2
  "An object relationship"
  current_royalty_v1: current_token_royalty_v1
  "An array relationship"
  current_token_ownerships("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): [current_token_ownerships_v2!]!
  "An aggregate relationship"
  current_token_ownerships_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): current_token_ownerships_v2_aggregate!
  decimals: bigint
  description: String!
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  maximum: numeric
  supply: numeric
  token_data_id: String!
  token_name: String!
  token_properties("JSON select path" path: String): jsonb
  token_standard: String!
  token_uri: String!
}

"Boolean expression to filter rows from the table \"current_token_datas_v2\". All fields are combined with a logical 'AND'."
input current_token_datas_v2_bool_exp {
  _and: [current_token_datas_v2_bool_exp!]
  _not: current_token_datas_v2_bool_exp
  _or: [current_token_datas_v2_bool_exp!]
  aptos_name: current_aptos_names_bool_exp
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_bool_exp
  collection_id: String_comparison_exp
  current_collection: current_collections_v2_bool_exp
  current_royalty_v1: current_token_royalty_v1_bool_exp
  current_token_ownerships: current_token_ownerships_v2_bool_exp
  current_token_ownerships_aggregate: current_token_ownerships_v2_aggregate_bool_exp
  decimals: bigint_comparison_exp
  description: String_comparison_exp
  is_deleted_v2: Boolean_comparison_exp
  is_fungible_v2: Boolean_comparison_exp
  largest_property_version_v1: numeric_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum: numeric_comparison_exp
  supply: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_name: String_comparison_exp
  token_properties: jsonb_comparison_exp
  token_standard: String_comparison_exp
  token_uri: String_comparison_exp
}

"Ordering options when selecting data from \"current_token_datas_v2\"."
input current_token_datas_v2_order_by {
  aptos_name: current_aptos_names_order_by
  cdn_asset_uris: nft_metadata_crawler_parsed_asset_uris_order_by
  collection_id: order_by
  current_collection: current_collections_v2_order_by
  current_royalty_v1: current_token_royalty_v1_order_by
  current_token_ownerships_aggregate: current_token_ownerships_v2_aggregate_order_by
  decimals: order_by
  description: order_by
  is_deleted_v2: order_by
  is_fungible_v2: order_by
  largest_property_version_v1: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum: order_by
  supply: order_by
  token_data_id: order_by
  token_name: order_by
  token_properties: order_by
  token_standard: order_by
  token_uri: order_by
}

"select columns of table \"current_token_datas_v2\""
enum current_token_datas_v2_select_column {
  "column name"
  collection_id
  "column name"
  decimals
  "column name"
  description
  "column name"
  is_deleted_v2
  "column name"
  is_fungible_v2
  "column name"
  largest_property_version_v1
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  maximum
  "column name"
  supply
  "column name"
  token_data_id
  "column name"
  token_name
  "column name"
  token_properties
  "column name"
  token_standard
  "column name"
  token_uri
}

"Streaming cursor of the table \"current_token_datas_v2\""
input current_token_datas_v2_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_datas_v2_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_datas_v2_stream_cursor_value_input {
  collection_id: String
  decimals: bigint
  description: String
  is_deleted_v2: Boolean
  is_fungible_v2: Boolean
  largest_property_version_v1: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum: numeric
  supply: numeric
  token_data_id: String
  token_name: String
  token_properties: jsonb
  token_standard: String
  token_uri: String
}

"columns and relationships of \"legacy_migration_v1.current_token_ownerships\""
type current_token_ownerships {
  amount: numeric
  "An object relationship"
  aptos_name: current_aptos_names
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  "An object relationship"
  current_collection_data: current_collection_datas
  "An object relationship"
  current_token_data: current_token_datas
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
  token_properties("JSON select path" path: String): jsonb
}

"aggregated selection of \"legacy_migration_v1.current_token_ownerships\""
type current_token_ownerships_aggregate {
  aggregate: current_token_ownerships_aggregate_fields
  nodes: [current_token_ownerships!]!
}

input current_token_ownerships_aggregate_bool_exp {
  count: current_token_ownerships_aggregate_bool_exp_count
}

input current_token_ownerships_aggregate_bool_exp_count {
  arguments: [current_token_ownerships_select_column!]
  distinct: Boolean
  filter: current_token_ownerships_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"legacy_migration_v1.current_token_ownerships\""
type current_token_ownerships_aggregate_fields {
  avg: current_token_ownerships_avg_fields
  count(columns: [current_token_ownerships_select_column!] distinct: Boolean): Int!
  max: current_token_ownerships_max_fields
  min: current_token_ownerships_min_fields
  stddev: current_token_ownerships_stddev_fields
  stddev_pop: current_token_ownerships_stddev_pop_fields
  stddev_samp: current_token_ownerships_stddev_samp_fields
  sum: current_token_ownerships_sum_fields
  var_pop: current_token_ownerships_var_pop_fields
  var_samp: current_token_ownerships_var_samp_fields
  variance: current_token_ownerships_variance_fields
}

"order by aggregate values of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_aggregate_order_by {
  avg: current_token_ownerships_avg_order_by
  count: order_by
  max: current_token_ownerships_max_order_by
  min: current_token_ownerships_min_order_by
  stddev: current_token_ownerships_stddev_order_by
  stddev_pop: current_token_ownerships_stddev_pop_order_by
  stddev_samp: current_token_ownerships_stddev_samp_order_by
  sum: current_token_ownerships_sum_order_by
  var_pop: current_token_ownerships_var_pop_order_by
  var_samp: current_token_ownerships_var_samp_order_by
  variance: current_token_ownerships_variance_order_by
}

"aggregate avg on columns"
type current_token_ownerships_avg_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by avg() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_avg_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.current_token_ownerships\". All fields are combined with a logical 'AND'."
input current_token_ownerships_bool_exp {
  _and: [current_token_ownerships_bool_exp!]
  _not: current_token_ownerships_bool_exp
  _or: [current_token_ownerships_bool_exp!]
  amount: numeric_comparison_exp
  aptos_name: current_aptos_names_bool_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  current_token_data: current_token_datas_bool_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  name: String_comparison_exp
  owner_address: String_comparison_exp
  property_version: numeric_comparison_exp
  table_type: String_comparison_exp
  token_data_id_hash: String_comparison_exp
  token_properties: jsonb_comparison_exp
}

"aggregate max on columns"
type current_token_ownerships_max_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
}

"order by max() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_max_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
}

"aggregate min on columns"
type current_token_ownerships_min_fields {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
}

"order by min() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_min_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
}

"Ordering options when selecting data from \"legacy_migration_v1.current_token_ownerships\"."
input current_token_ownerships_order_by {
  amount: order_by
  aptos_name: current_aptos_names_order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  current_token_data: current_token_datas_order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_type: order_by
  token_data_id_hash: order_by
  token_properties: order_by
}

"select columns of table \"legacy_migration_v1.current_token_ownerships\""
enum current_token_ownerships_select_column {
  "column name"
  amount
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  name
  "column name"
  owner_address
  "column name"
  property_version
  "column name"
  table_type
  "column name"
  token_data_id_hash
  "column name"
  token_properties
}

"aggregate stddev on columns"
type current_token_ownerships_stddev_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by stddev() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_stddev_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"aggregate stddev_pop on columns"
type current_token_ownerships_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by stddev_pop() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_stddev_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"aggregate stddev_samp on columns"
type current_token_ownerships_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by stddev_samp() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_stddev_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"Streaming cursor of the table \"current_token_ownerships\""
input current_token_ownerships_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_ownerships_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_ownerships_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  owner_address: String
  property_version: numeric
  table_type: String
  token_data_id_hash: String
  token_properties: jsonb
}

"aggregate sum on columns"
type current_token_ownerships_sum_fields {
  amount: numeric
  last_transaction_version: bigint
  property_version: numeric
}

"order by sum() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_sum_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"columns and relationships of \"current_token_ownerships_v2\""
type current_token_ownerships_v2 {
  amount: numeric!
  "An array relationship"
  composed_nfts("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): [current_token_ownerships_v2!]!
  "An aggregate relationship"
  composed_nfts_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): current_token_ownerships_v2_aggregate!
  "An object relationship"
  current_token_data: current_token_datas_v2
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  non_transferrable_by_owner: Boolean
  owner_address: String!
  property_version_v1: numeric!
  storage_id: String!
  table_type_v1: String
  token_data_id: String!
  token_properties_mutated_v1("JSON select path" path: String): jsonb
  token_standard: String!
}

"aggregated selection of \"current_token_ownerships_v2\""
type current_token_ownerships_v2_aggregate {
  aggregate: current_token_ownerships_v2_aggregate_fields
  nodes: [current_token_ownerships_v2!]!
}

input current_token_ownerships_v2_aggregate_bool_exp {
  bool_and: current_token_ownerships_v2_aggregate_bool_exp_bool_and
  bool_or: current_token_ownerships_v2_aggregate_bool_exp_bool_or
  count: current_token_ownerships_v2_aggregate_bool_exp_count
}

input current_token_ownerships_v2_aggregate_bool_exp_bool_and {
  arguments: current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_token_ownerships_v2_aggregate_bool_exp_bool_or {
  arguments: current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input current_token_ownerships_v2_aggregate_bool_exp_count {
  arguments: [current_token_ownerships_v2_select_column!]
  distinct: Boolean
  filter: current_token_ownerships_v2_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"current_token_ownerships_v2\""
type current_token_ownerships_v2_aggregate_fields {
  avg: current_token_ownerships_v2_avg_fields
  count(columns: [current_token_ownerships_v2_select_column!] distinct: Boolean): Int!
  max: current_token_ownerships_v2_max_fields
  min: current_token_ownerships_v2_min_fields
  stddev: current_token_ownerships_v2_stddev_fields
  stddev_pop: current_token_ownerships_v2_stddev_pop_fields
  stddev_samp: current_token_ownerships_v2_stddev_samp_fields
  sum: current_token_ownerships_v2_sum_fields
  var_pop: current_token_ownerships_v2_var_pop_fields
  var_samp: current_token_ownerships_v2_var_samp_fields
  variance: current_token_ownerships_v2_variance_fields
}

"order by aggregate values of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_aggregate_order_by {
  avg: current_token_ownerships_v2_avg_order_by
  count: order_by
  max: current_token_ownerships_v2_max_order_by
  min: current_token_ownerships_v2_min_order_by
  stddev: current_token_ownerships_v2_stddev_order_by
  stddev_pop: current_token_ownerships_v2_stddev_pop_order_by
  stddev_samp: current_token_ownerships_v2_stddev_samp_order_by
  sum: current_token_ownerships_v2_sum_order_by
  var_pop: current_token_ownerships_v2_var_pop_order_by
  var_samp: current_token_ownerships_v2_var_samp_order_by
  variance: current_token_ownerships_v2_variance_order_by
}

"aggregate avg on columns"
type current_token_ownerships_v2_avg_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by avg() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_avg_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"Boolean expression to filter rows from the table \"current_token_ownerships_v2\". All fields are combined with a logical 'AND'."
input current_token_ownerships_v2_bool_exp {
  _and: [current_token_ownerships_v2_bool_exp!]
  _not: current_token_ownerships_v2_bool_exp
  _or: [current_token_ownerships_v2_bool_exp!]
  amount: numeric_comparison_exp
  composed_nfts: current_token_ownerships_v2_bool_exp
  composed_nfts_aggregate: current_token_ownerships_v2_aggregate_bool_exp
  current_token_data: current_token_datas_v2_bool_exp
  is_fungible_v2: Boolean_comparison_exp
  is_soulbound_v2: Boolean_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  non_transferrable_by_owner: Boolean_comparison_exp
  owner_address: String_comparison_exp
  property_version_v1: numeric_comparison_exp
  storage_id: String_comparison_exp
  table_type_v1: String_comparison_exp
  token_data_id: String_comparison_exp
  token_properties_mutated_v1: jsonb_comparison_exp
  token_standard: String_comparison_exp
}

"aggregate max on columns"
type current_token_ownerships_v2_max_fields {
  amount: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_standard: String
}

"order by max() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_max_order_by {
  amount: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_standard: order_by
}

"aggregate min on columns"
type current_token_ownerships_v2_min_fields {
  amount: numeric
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_standard: String
}

"order by min() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_min_order_by {
  amount: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_standard: order_by
}

"Ordering options when selecting data from \"current_token_ownerships_v2\"."
input current_token_ownerships_v2_order_by {
  amount: order_by
  composed_nfts_aggregate: current_token_ownerships_v2_aggregate_order_by
  current_token_data: current_token_datas_v2_order_by
  is_fungible_v2: order_by
  is_soulbound_v2: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  non_transferrable_by_owner: order_by
  owner_address: order_by
  property_version_v1: order_by
  storage_id: order_by
  table_type_v1: order_by
  token_data_id: order_by
  token_properties_mutated_v1: order_by
  token_standard: order_by
}

"select columns of table \"current_token_ownerships_v2\""
enum current_token_ownerships_v2_select_column {
  "column name"
  amount
  "column name"
  is_fungible_v2
  "column name"
  is_soulbound_v2
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  non_transferrable_by_owner
  "column name"
  owner_address
  "column name"
  property_version_v1
  "column name"
  storage_id
  "column name"
  table_type_v1
  "column name"
  token_data_id
  "column name"
  token_properties_mutated_v1
  "column name"
  token_standard
}

"select \"current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"current_token_ownerships_v2\""
enum current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_fungible_v2
  "column name"
  is_soulbound_v2
  "column name"
  non_transferrable_by_owner
}

"select \"current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"current_token_ownerships_v2\""
enum current_token_ownerships_v2_select_column_current_token_ownerships_v2_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_fungible_v2
  "column name"
  is_soulbound_v2
  "column name"
  non_transferrable_by_owner
}

"aggregate stddev on columns"
type current_token_ownerships_v2_stddev_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by stddev() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_stddev_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate stddev_pop on columns"
type current_token_ownerships_v2_stddev_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by stddev_pop() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_stddev_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate stddev_samp on columns"
type current_token_ownerships_v2_stddev_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by stddev_samp() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_stddev_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"Streaming cursor of the table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_ownerships_v2_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_ownerships_v2_stream_cursor_value_input {
  amount: numeric
  is_fungible_v2: Boolean
  is_soulbound_v2: Boolean
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  non_transferrable_by_owner: Boolean
  owner_address: String
  property_version_v1: numeric
  storage_id: String
  table_type_v1: String
  token_data_id: String
  token_properties_mutated_v1: jsonb
  token_standard: String
}

"aggregate sum on columns"
type current_token_ownerships_v2_sum_fields {
  amount: numeric
  last_transaction_version: bigint
  property_version_v1: numeric
}

"order by sum() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_sum_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate var_pop on columns"
type current_token_ownerships_v2_var_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by var_pop() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_var_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate var_samp on columns"
type current_token_ownerships_v2_var_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by var_samp() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_var_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate variance on columns"
type current_token_ownerships_v2_variance_fields {
  amount: Float
  last_transaction_version: Float
  property_version_v1: Float
}

"order by variance() on columns of table \"current_token_ownerships_v2\""
input current_token_ownerships_v2_variance_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version_v1: order_by
}

"aggregate var_pop on columns"
type current_token_ownerships_var_pop_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by var_pop() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_var_pop_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"aggregate var_samp on columns"
type current_token_ownerships_var_samp_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by var_samp() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_var_samp_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"aggregate variance on columns"
type current_token_ownerships_variance_fields {
  amount: Float
  last_transaction_version: Float
  property_version: Float
}

"order by variance() on columns of table \"legacy_migration_v1.current_token_ownerships\""
input current_token_ownerships_variance_order_by {
  amount: order_by
  last_transaction_version: order_by
  property_version: order_by
}

"columns and relationships of \"current_token_pending_claims\""
type current_token_pending_claims {
  amount: numeric!
  collection_data_id_hash: String!
  collection_id: String!
  collection_name: String!
  creator_address: String!
  "An object relationship"
  current_collection_data: current_collection_datas
  "An object relationship"
  current_collection_v2: current_collections_v2
  "An object relationship"
  current_token_data: current_token_datas
  "An object relationship"
  current_token_data_v2: current_token_datas_v2
  from_address: String!
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  name: String!
  property_version: numeric!
  table_handle: String!
  to_address: String!
  "An object relationship"
  token: tokens
  token_data_id: String!
  token_data_id_hash: String!
}

"Boolean expression to filter rows from the table \"current_token_pending_claims\". All fields are combined with a logical 'AND'."
input current_token_pending_claims_bool_exp {
  _and: [current_token_pending_claims_bool_exp!]
  _not: current_token_pending_claims_bool_exp
  _or: [current_token_pending_claims_bool_exp!]
  amount: numeric_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_collection_data: current_collection_datas_bool_exp
  current_collection_v2: current_collections_v2_bool_exp
  current_token_data: current_token_datas_bool_exp
  current_token_data_v2: current_token_datas_v2_bool_exp
  from_address: String_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  table_handle: String_comparison_exp
  to_address: String_comparison_exp
  token: tokens_bool_exp
  token_data_id: String_comparison_exp
  token_data_id_hash: String_comparison_exp
}

"Ordering options when selecting data from \"current_token_pending_claims\"."
input current_token_pending_claims_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_id: order_by
  collection_name: order_by
  creator_address: order_by
  current_collection_data: current_collection_datas_order_by
  current_collection_v2: current_collections_v2_order_by
  current_token_data: current_token_datas_order_by
  current_token_data_v2: current_token_datas_v2_order_by
  from_address: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  name: order_by
  property_version: order_by
  table_handle: order_by
  to_address: order_by
  token: tokens_order_by
  token_data_id: order_by
  token_data_id_hash: order_by
}

"select columns of table \"current_token_pending_claims\""
enum current_token_pending_claims_select_column {
  "column name"
  amount
  "column name"
  collection_data_id_hash
  "column name"
  collection_id
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  from_address
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  name
  "column name"
  property_version
  "column name"
  table_handle
  "column name"
  to_address
  "column name"
  token_data_id
  "column name"
  token_data_id_hash
}

"Streaming cursor of the table \"current_token_pending_claims\""
input current_token_pending_claims_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_pending_claims_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_pending_claims_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_id: String
  collection_name: String
  creator_address: String
  from_address: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  name: String
  property_version: numeric
  table_handle: String
  to_address: String
  token_data_id: String
  token_data_id_hash: String
}

"columns and relationships of \"current_token_royalty_v1\""
type current_token_royalty_v1 {
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  payee_address: String!
  royalty_points_denominator: numeric!
  royalty_points_numerator: numeric!
  token_data_id: String!
}

"Boolean expression to filter rows from the table \"current_token_royalty_v1\". All fields are combined with a logical 'AND'."
input current_token_royalty_v1_bool_exp {
  _and: [current_token_royalty_v1_bool_exp!]
  _not: current_token_royalty_v1_bool_exp
  _or: [current_token_royalty_v1_bool_exp!]
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  payee_address: String_comparison_exp
  royalty_points_denominator: numeric_comparison_exp
  royalty_points_numerator: numeric_comparison_exp
  token_data_id: String_comparison_exp
}

"Ordering options when selecting data from \"current_token_royalty_v1\"."
input current_token_royalty_v1_order_by {
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  payee_address: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  token_data_id: order_by
}

"select columns of table \"current_token_royalty_v1\""
enum current_token_royalty_v1_select_column {
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  payee_address
  "column name"
  royalty_points_denominator
  "column name"
  royalty_points_numerator
  "column name"
  token_data_id
}

"Streaming cursor of the table \"current_token_royalty_v1\""
input current_token_royalty_v1_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: current_token_royalty_v1_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input current_token_royalty_v1_stream_cursor_value_input {
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  payee_address: String
  royalty_points_denominator: numeric
  royalty_points_numerator: numeric
  token_data_id: String
}

"ordering argument of a cursor"
enum cursor_ordering {
  "ascending ordering of the cursor"
  ASC
  "descending ordering of the cursor"
  DESC
}

"columns and relationships of \"delegated_staking_activities\""
type delegated_staking_activities {
  amount: numeric!
  delegator_address: String!
  event_index: bigint!
  event_type: String!
  pool_address: String!
  transaction_version: bigint!
}

"order by aggregate values of table \"delegated_staking_activities\""
input delegated_staking_activities_aggregate_order_by {
  avg: delegated_staking_activities_avg_order_by
  count: order_by
  max: delegated_staking_activities_max_order_by
  min: delegated_staking_activities_min_order_by
  stddev: delegated_staking_activities_stddev_order_by
  stddev_pop: delegated_staking_activities_stddev_pop_order_by
  stddev_samp: delegated_staking_activities_stddev_samp_order_by
  sum: delegated_staking_activities_sum_order_by
  var_pop: delegated_staking_activities_var_pop_order_by
  var_samp: delegated_staking_activities_var_samp_order_by
  variance: delegated_staking_activities_variance_order_by
}

"order by avg() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_avg_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"Boolean expression to filter rows from the table \"delegated_staking_activities\". All fields are combined with a logical 'AND'."
input delegated_staking_activities_bool_exp {
  _and: [delegated_staking_activities_bool_exp!]
  _not: delegated_staking_activities_bool_exp
  _or: [delegated_staking_activities_bool_exp!]
  amount: numeric_comparison_exp
  delegator_address: String_comparison_exp
  event_index: bigint_comparison_exp
  event_type: String_comparison_exp
  pool_address: String_comparison_exp
  transaction_version: bigint_comparison_exp
}

"order by max() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_max_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  pool_address: order_by
  transaction_version: order_by
}

"order by min() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_min_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  pool_address: order_by
  transaction_version: order_by
}

"Ordering options when selecting data from \"delegated_staking_activities\"."
input delegated_staking_activities_order_by {
  amount: order_by
  delegator_address: order_by
  event_index: order_by
  event_type: order_by
  pool_address: order_by
  transaction_version: order_by
}

"select columns of table \"delegated_staking_activities\""
enum delegated_staking_activities_select_column {
  "column name"
  amount
  "column name"
  delegator_address
  "column name"
  event_index
  "column name"
  event_type
  "column name"
  pool_address
  "column name"
  transaction_version
}

"order by stddev() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_stddev_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"order by stddev_pop() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_stddev_pop_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"order by stddev_samp() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_stddev_samp_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"Streaming cursor of the table \"delegated_staking_activities\""
input delegated_staking_activities_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: delegated_staking_activities_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input delegated_staking_activities_stream_cursor_value_input {
  amount: numeric
  delegator_address: String
  event_index: bigint
  event_type: String
  pool_address: String
  transaction_version: bigint
}

"order by sum() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_sum_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"order by var_pop() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_var_pop_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"order by var_samp() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_var_samp_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"order by variance() on columns of table \"delegated_staking_activities\""
input delegated_staking_activities_variance_order_by {
  amount: order_by
  event_index: order_by
  transaction_version: order_by
}

"columns and relationships of \"delegated_staking_pool_balances\""
type delegated_staking_pool_balances {
  active_table_handle: String!
  inactive_table_handle: String!
  operator_commission_percentage: numeric!
  staking_pool_address: String!
  total_coins: numeric!
  total_shares: numeric!
  transaction_version: bigint!
}

"aggregated selection of \"delegated_staking_pool_balances\""
type delegated_staking_pool_balances_aggregate {
  aggregate: delegated_staking_pool_balances_aggregate_fields
  nodes: [delegated_staking_pool_balances!]!
}

"aggregate fields of \"delegated_staking_pool_balances\""
type delegated_staking_pool_balances_aggregate_fields {
  avg: delegated_staking_pool_balances_avg_fields
  count(columns: [delegated_staking_pool_balances_select_column!] distinct: Boolean): Int!
  max: delegated_staking_pool_balances_max_fields
  min: delegated_staking_pool_balances_min_fields
  stddev: delegated_staking_pool_balances_stddev_fields
  stddev_pop: delegated_staking_pool_balances_stddev_pop_fields
  stddev_samp: delegated_staking_pool_balances_stddev_samp_fields
  sum: delegated_staking_pool_balances_sum_fields
  var_pop: delegated_staking_pool_balances_var_pop_fields
  var_samp: delegated_staking_pool_balances_var_samp_fields
  variance: delegated_staking_pool_balances_variance_fields
}

"aggregate avg on columns"
type delegated_staking_pool_balances_avg_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"delegated_staking_pool_balances\". All fields are combined with a logical 'AND'."
input delegated_staking_pool_balances_bool_exp {
  _and: [delegated_staking_pool_balances_bool_exp!]
  _not: delegated_staking_pool_balances_bool_exp
  _or: [delegated_staking_pool_balances_bool_exp!]
  active_table_handle: String_comparison_exp
  inactive_table_handle: String_comparison_exp
  operator_commission_percentage: numeric_comparison_exp
  staking_pool_address: String_comparison_exp
  total_coins: numeric_comparison_exp
  total_shares: numeric_comparison_exp
  transaction_version: bigint_comparison_exp
}

"aggregate max on columns"
type delegated_staking_pool_balances_max_fields {
  active_table_handle: String
  inactive_table_handle: String
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"aggregate min on columns"
type delegated_staking_pool_balances_min_fields {
  active_table_handle: String
  inactive_table_handle: String
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"Ordering options when selecting data from \"delegated_staking_pool_balances\"."
input delegated_staking_pool_balances_order_by {
  active_table_handle: order_by
  inactive_table_handle: order_by
  operator_commission_percentage: order_by
  staking_pool_address: order_by
  total_coins: order_by
  total_shares: order_by
  transaction_version: order_by
}

"select columns of table \"delegated_staking_pool_balances\""
enum delegated_staking_pool_balances_select_column {
  "column name"
  active_table_handle
  "column name"
  inactive_table_handle
  "column name"
  operator_commission_percentage
  "column name"
  staking_pool_address
  "column name"
  total_coins
  "column name"
  total_shares
  "column name"
  transaction_version
}

"aggregate stddev on columns"
type delegated_staking_pool_balances_stddev_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type delegated_staking_pool_balances_stddev_pop_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type delegated_staking_pool_balances_stddev_samp_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"Streaming cursor of the table \"delegated_staking_pool_balances\""
input delegated_staking_pool_balances_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: delegated_staking_pool_balances_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input delegated_staking_pool_balances_stream_cursor_value_input {
  active_table_handle: String
  inactive_table_handle: String
  operator_commission_percentage: numeric
  staking_pool_address: String
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"aggregate sum on columns"
type delegated_staking_pool_balances_sum_fields {
  operator_commission_percentage: numeric
  total_coins: numeric
  total_shares: numeric
  transaction_version: bigint
}

"aggregate var_pop on columns"
type delegated_staking_pool_balances_var_pop_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"aggregate var_samp on columns"
type delegated_staking_pool_balances_var_samp_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"aggregate variance on columns"
type delegated_staking_pool_balances_variance_fields {
  operator_commission_percentage: Float
  total_coins: Float
  total_shares: Float
  transaction_version: Float
}

"columns and relationships of \"delegated_staking_pools\""
type delegated_staking_pools {
  "An object relationship"
  current_staking_pool: current_staking_pool_voter
  first_transaction_version: bigint!
  staking_pool_address: String!
}

"Boolean expression to filter rows from the table \"delegated_staking_pools\". All fields are combined with a logical 'AND'."
input delegated_staking_pools_bool_exp {
  _and: [delegated_staking_pools_bool_exp!]
  _not: delegated_staking_pools_bool_exp
  _or: [delegated_staking_pools_bool_exp!]
  current_staking_pool: current_staking_pool_voter_bool_exp
  first_transaction_version: bigint_comparison_exp
  staking_pool_address: String_comparison_exp
}

"Ordering options when selecting data from \"delegated_staking_pools\"."
input delegated_staking_pools_order_by {
  current_staking_pool: current_staking_pool_voter_order_by
  first_transaction_version: order_by
  staking_pool_address: order_by
}

"select columns of table \"delegated_staking_pools\""
enum delegated_staking_pools_select_column {
  "column name"
  first_transaction_version
  "column name"
  staking_pool_address
}

"Streaming cursor of the table \"delegated_staking_pools\""
input delegated_staking_pools_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: delegated_staking_pools_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input delegated_staking_pools_stream_cursor_value_input {
  first_transaction_version: bigint
  staking_pool_address: String
}

"columns and relationships of \"delegator_distinct_pool\""
type delegator_distinct_pool {
  "An object relationship"
  current_pool_balance: current_delegated_staking_pool_balances
  delegator_address: String
  pool_address: String
  "An object relationship"
  staking_pool_metadata: current_staking_pool_voter
}

"aggregated selection of \"delegator_distinct_pool\""
type delegator_distinct_pool_aggregate {
  aggregate: delegator_distinct_pool_aggregate_fields
  nodes: [delegator_distinct_pool!]!
}

"aggregate fields of \"delegator_distinct_pool\""
type delegator_distinct_pool_aggregate_fields {
  count(columns: [delegator_distinct_pool_select_column!] distinct: Boolean): Int!
  max: delegator_distinct_pool_max_fields
  min: delegator_distinct_pool_min_fields
}

"Boolean expression to filter rows from the table \"delegator_distinct_pool\". All fields are combined with a logical 'AND'."
input delegator_distinct_pool_bool_exp {
  _and: [delegator_distinct_pool_bool_exp!]
  _not: delegator_distinct_pool_bool_exp
  _or: [delegator_distinct_pool_bool_exp!]
  current_pool_balance: current_delegated_staking_pool_balances_bool_exp
  delegator_address: String_comparison_exp
  pool_address: String_comparison_exp
  staking_pool_metadata: current_staking_pool_voter_bool_exp
}

"aggregate max on columns"
type delegator_distinct_pool_max_fields {
  delegator_address: String
  pool_address: String
}

"aggregate min on columns"
type delegator_distinct_pool_min_fields {
  delegator_address: String
  pool_address: String
}

"Ordering options when selecting data from \"delegator_distinct_pool\"."
input delegator_distinct_pool_order_by {
  current_pool_balance: current_delegated_staking_pool_balances_order_by
  delegator_address: order_by
  pool_address: order_by
  staking_pool_metadata: current_staking_pool_voter_order_by
}

"select columns of table \"delegator_distinct_pool\""
enum delegator_distinct_pool_select_column {
  "column name"
  delegator_address
  "column name"
  pool_address
}

"Streaming cursor of the table \"delegator_distinct_pool\""
input delegator_distinct_pool_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: delegator_distinct_pool_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input delegator_distinct_pool_stream_cursor_value_input {
  delegator_address: String
  pool_address: String
}

"columns and relationships of \"events\""
type events {
  account_address: String!
  creation_number: bigint!
  data("JSON select path" path: String): jsonb
  event_index: bigint!
  indexed_type: String!
  sequence_number: bigint!
  transaction_block_height: bigint!
  transaction_version: bigint!
  type: String!
}

"Boolean expression to filter rows from the table \"events\". All fields are combined with a logical 'AND'."
input events_bool_exp {
  _and: [events_bool_exp!]
  _not: events_bool_exp
  _or: [events_bool_exp!]
  account_address: String_comparison_exp
  creation_number: bigint_comparison_exp
  data: jsonb_comparison_exp
  event_index: bigint_comparison_exp
  indexed_type: String_comparison_exp
  sequence_number: bigint_comparison_exp
  transaction_block_height: bigint_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"events\"."
input events_order_by {
  account_address: order_by
  creation_number: order_by
  data: order_by
  event_index: order_by
  indexed_type: order_by
  sequence_number: order_by
  transaction_block_height: order_by
  transaction_version: order_by
  type: order_by
}

"select columns of table \"events\""
enum events_select_column {
  "column name"
  account_address
  "column name"
  creation_number
  "column name"
  data
  "column name"
  event_index
  "column name"
  indexed_type
  "column name"
  sequence_number
  "column name"
  transaction_block_height
  "column name"
  transaction_version
  "column name"
  type
}

"Streaming cursor of the table \"events\""
input events_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: events_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input events_stream_cursor_value_input {
  account_address: String
  creation_number: bigint
  data: jsonb
  event_index: bigint
  indexed_type: String
  sequence_number: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

"columns and relationships of \"fungible_asset_activities\""
type fungible_asset_activities {
  amount: numeric
  asset_type: String
  block_height: bigint!
  entry_function_id_str: String
  event_index: bigint!
  gas_fee_payer_address: String
  is_frozen: Boolean
  is_gas_fee: Boolean!
  is_transaction_success: Boolean!
  "An object relationship"
  metadata: fungible_asset_metadata
  owner_address: String
  "An array relationship"
  owner_aptos_names("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  owner_aptos_names_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  storage_id: String!
  storage_refund_amount: numeric!
  token_standard: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  type: String!
}

"order by aggregate values of table \"fungible_asset_activities\""
input fungible_asset_activities_aggregate_order_by {
  avg: fungible_asset_activities_avg_order_by
  count: order_by
  max: fungible_asset_activities_max_order_by
  min: fungible_asset_activities_min_order_by
  stddev: fungible_asset_activities_stddev_order_by
  stddev_pop: fungible_asset_activities_stddev_pop_order_by
  stddev_samp: fungible_asset_activities_stddev_samp_order_by
  sum: fungible_asset_activities_sum_order_by
  var_pop: fungible_asset_activities_var_pop_order_by
  var_samp: fungible_asset_activities_var_samp_order_by
  variance: fungible_asset_activities_variance_order_by
}

"order by avg() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_avg_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"Boolean expression to filter rows from the table \"fungible_asset_activities\". All fields are combined with a logical 'AND'."
input fungible_asset_activities_bool_exp {
  _and: [fungible_asset_activities_bool_exp!]
  _not: fungible_asset_activities_bool_exp
  _or: [fungible_asset_activities_bool_exp!]
  amount: numeric_comparison_exp
  asset_type: String_comparison_exp
  block_height: bigint_comparison_exp
  entry_function_id_str: String_comparison_exp
  event_index: bigint_comparison_exp
  gas_fee_payer_address: String_comparison_exp
  is_frozen: Boolean_comparison_exp
  is_gas_fee: Boolean_comparison_exp
  is_transaction_success: Boolean_comparison_exp
  metadata: fungible_asset_metadata_bool_exp
  owner_address: String_comparison_exp
  owner_aptos_names: current_aptos_names_bool_exp
  owner_aptos_names_aggregate: current_aptos_names_aggregate_bool_exp
  storage_id: String_comparison_exp
  storage_refund_amount: numeric_comparison_exp
  token_standard: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"order by max() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_max_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  owner_address: order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"order by min() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_min_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  owner_address: order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"Ordering options when selecting data from \"fungible_asset_activities\"."
input fungible_asset_activities_order_by {
  amount: order_by
  asset_type: order_by
  block_height: order_by
  entry_function_id_str: order_by
  event_index: order_by
  gas_fee_payer_address: order_by
  is_frozen: order_by
  is_gas_fee: order_by
  is_transaction_success: order_by
  metadata: fungible_asset_metadata_order_by
  owner_address: order_by
  owner_aptos_names_aggregate: current_aptos_names_aggregate_order_by
  storage_id: order_by
  storage_refund_amount: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"select columns of table \"fungible_asset_activities\""
enum fungible_asset_activities_select_column {
  "column name"
  amount
  "column name"
  asset_type
  "column name"
  block_height
  "column name"
  entry_function_id_str
  "column name"
  event_index
  "column name"
  gas_fee_payer_address
  "column name"
  is_frozen
  "column name"
  is_gas_fee
  "column name"
  is_transaction_success
  "column name"
  owner_address
  "column name"
  storage_id
  "column name"
  storage_refund_amount
  "column name"
  token_standard
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  type
}

"order by stddev() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_stddev_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"order by stddev_pop() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_stddev_pop_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"order by stddev_samp() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_stddev_samp_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"Streaming cursor of the table \"fungible_asset_activities\""
input fungible_asset_activities_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fungible_asset_activities_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fungible_asset_activities_stream_cursor_value_input {
  amount: numeric
  asset_type: String
  block_height: bigint
  entry_function_id_str: String
  event_index: bigint
  gas_fee_payer_address: String
  is_frozen: Boolean
  is_gas_fee: Boolean
  is_transaction_success: Boolean
  owner_address: String
  storage_id: String
  storage_refund_amount: numeric
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"order by sum() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_sum_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"order by var_pop() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_var_pop_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"order by var_samp() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_var_samp_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"order by variance() on columns of table \"fungible_asset_activities\""
input fungible_asset_activities_variance_order_by {
  amount: order_by
  block_height: order_by
  event_index: order_by
  storage_refund_amount: order_by
  transaction_version: order_by
}

"columns and relationships of \"fungible_asset_metadata\""
type fungible_asset_metadata {
  asset_type: String!
  creator_address: String!
  decimals: Int!
  icon_uri: String
  last_transaction_timestamp: timestamp!
  last_transaction_version: bigint!
  maximum_v2: numeric
  name: String!
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String!
  token_standard: String!
}

"Boolean expression to filter rows from the table \"fungible_asset_metadata\". All fields are combined with a logical 'AND'."
input fungible_asset_metadata_bool_exp {
  _and: [fungible_asset_metadata_bool_exp!]
  _not: fungible_asset_metadata_bool_exp
  _or: [fungible_asset_metadata_bool_exp!]
  asset_type: String_comparison_exp
  creator_address: String_comparison_exp
  decimals: Int_comparison_exp
  icon_uri: String_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_transaction_version: bigint_comparison_exp
  maximum_v2: numeric_comparison_exp
  name: String_comparison_exp
  project_uri: String_comparison_exp
  supply_aggregator_table_handle_v1: String_comparison_exp
  supply_aggregator_table_key_v1: String_comparison_exp
  supply_v2: numeric_comparison_exp
  symbol: String_comparison_exp
  token_standard: String_comparison_exp
}

"Ordering options when selecting data from \"fungible_asset_metadata\"."
input fungible_asset_metadata_order_by {
  asset_type: order_by
  creator_address: order_by
  decimals: order_by
  icon_uri: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  maximum_v2: order_by
  name: order_by
  project_uri: order_by
  supply_aggregator_table_handle_v1: order_by
  supply_aggregator_table_key_v1: order_by
  supply_v2: order_by
  symbol: order_by
  token_standard: order_by
}

"select columns of table \"fungible_asset_metadata\""
enum fungible_asset_metadata_select_column {
  "column name"
  asset_type
  "column name"
  creator_address
  "column name"
  decimals
  "column name"
  icon_uri
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  maximum_v2
  "column name"
  name
  "column name"
  project_uri
  "column name"
  supply_aggregator_table_handle_v1
  "column name"
  supply_aggregator_table_key_v1
  "column name"
  supply_v2
  "column name"
  symbol
  "column name"
  token_standard
}

"Streaming cursor of the table \"fungible_asset_metadata\""
input fungible_asset_metadata_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: fungible_asset_metadata_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input fungible_asset_metadata_stream_cursor_value_input {
  asset_type: String
  creator_address: String
  decimals: Int
  icon_uri: String
  last_transaction_timestamp: timestamp
  last_transaction_version: bigint
  maximum_v2: numeric
  name: String
  project_uri: String
  supply_aggregator_table_handle_v1: String
  supply_aggregator_table_key_v1: String
  supply_v2: numeric
  symbol: String
  token_standard: String
}

"columns and relationships of \"indexer_status\""
type indexer_status {
  db: String!
  is_indexer_up: Boolean!
}

"Boolean expression to filter rows from the table \"indexer_status\". All fields are combined with a logical 'AND'."
input indexer_status_bool_exp {
  _and: [indexer_status_bool_exp!]
  _not: indexer_status_bool_exp
  _or: [indexer_status_bool_exp!]
  db: String_comparison_exp
  is_indexer_up: Boolean_comparison_exp
}

"Ordering options when selecting data from \"indexer_status\"."
input indexer_status_order_by {
  db: order_by
  is_indexer_up: order_by
}

"select columns of table \"indexer_status\""
enum indexer_status_select_column {
  "column name"
  db
  "column name"
  is_indexer_up
}

"Streaming cursor of the table \"indexer_status\""
input indexer_status_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: indexer_status_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input indexer_status_stream_cursor_value_input {
  db: String
  is_indexer_up: Boolean
}

scalar jsonb

input jsonb_cast_exp {
  String: String_comparison_exp
}

"Boolean expression to compare columns of type \"jsonb\". All fields are combined with logical 'AND'."
input jsonb_comparison_exp {
  _cast: jsonb_cast_exp
  "is the column contained in the given json value"
  _contained_in: jsonb
  "does the column contain the given json value at the top level"
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb
  "does the string exist as a top-level key in the column"
  _has_key: String
  "do all of these strings exist as top-level keys in the column"
  _has_keys_all: [String!]
  "do any of these strings exist as top-level keys in the column"
  _has_keys_any: [String!]
  _in: [jsonb]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb]
}

"columns and relationships of \"ledger_infos\""
type ledger_infos {
  chain_id: bigint!
}

"Boolean expression to filter rows from the table \"ledger_infos\". All fields are combined with a logical 'AND'."
input ledger_infos_bool_exp {
  _and: [ledger_infos_bool_exp!]
  _not: ledger_infos_bool_exp
  _or: [ledger_infos_bool_exp!]
  chain_id: bigint_comparison_exp
}

"Ordering options when selecting data from \"ledger_infos\"."
input ledger_infos_order_by {
  chain_id: order_by
}

"select columns of table \"ledger_infos\""
enum ledger_infos_select_column {
  "column name"
  chain_id
}

"Streaming cursor of the table \"ledger_infos\""
input ledger_infos_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: ledger_infos_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input ledger_infos_stream_cursor_value_input {
  chain_id: bigint
}

"columns and relationships of \"legacy_migration_v1.move_resources\""
type move_resources {
  address: String
  transaction_version: bigint
}

"aggregated selection of \"legacy_migration_v1.move_resources\""
type move_resources_aggregate {
  aggregate: move_resources_aggregate_fields
  nodes: [move_resources!]!
}

"aggregate fields of \"legacy_migration_v1.move_resources\""
type move_resources_aggregate_fields {
  avg: move_resources_avg_fields
  count(columns: [move_resources_select_column!] distinct: Boolean): Int!
  max: move_resources_max_fields
  min: move_resources_min_fields
  stddev: move_resources_stddev_fields
  stddev_pop: move_resources_stddev_pop_fields
  stddev_samp: move_resources_stddev_samp_fields
  sum: move_resources_sum_fields
  var_pop: move_resources_var_pop_fields
  var_samp: move_resources_var_samp_fields
  variance: move_resources_variance_fields
}

"aggregate avg on columns"
type move_resources_avg_fields {
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.move_resources\". All fields are combined with a logical 'AND'."
input move_resources_bool_exp {
  _and: [move_resources_bool_exp!]
  _not: move_resources_bool_exp
  _or: [move_resources_bool_exp!]
  address: String_comparison_exp
  transaction_version: bigint_comparison_exp
}

"aggregate max on columns"
type move_resources_max_fields {
  address: String
  transaction_version: bigint
}

"aggregate min on columns"
type move_resources_min_fields {
  address: String
  transaction_version: bigint
}

"Ordering options when selecting data from \"legacy_migration_v1.move_resources\"."
input move_resources_order_by {
  address: order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.move_resources\""
enum move_resources_select_column {
  "column name"
  address
  "column name"
  transaction_version
}

"aggregate stddev on columns"
type move_resources_stddev_fields {
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type move_resources_stddev_pop_fields {
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type move_resources_stddev_samp_fields {
  transaction_version: Float
}

"Streaming cursor of the table \"move_resources\""
input move_resources_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: move_resources_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input move_resources_stream_cursor_value_input {
  address: String
  transaction_version: bigint
}

"aggregate sum on columns"
type move_resources_sum_fields {
  transaction_version: bigint
}

"aggregate var_pop on columns"
type move_resources_var_pop_fields {
  transaction_version: Float
}

"aggregate var_samp on columns"
type move_resources_var_samp_fields {
  transaction_version: Float
}

"aggregate variance on columns"
type move_resources_variance_fields {
  transaction_version: Float
}

"columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_auctions\""
type nft_marketplace_v2_current_nft_marketplace_auctions {
  buy_it_now_price: numeric
  coin_type: String
  collection_id: String!
  contract_address: String!
  current_bid_price: numeric
  current_bidder: String
  "An object relationship"
  current_token_data: current_token_datas_v2
  entry_function_id_str: String!
  expiration_time: numeric!
  fee_schedule_id: String!
  is_deleted: Boolean!
  last_transaction_timestamp: timestamptz!
  last_transaction_version: bigint!
  listing_id: String!
  marketplace: String!
  seller: String!
  starting_bid_price: numeric!
  token_amount: numeric!
  token_data_id: String!
  token_standard: String!
}

"Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_auctions\". All fields are combined with a logical 'AND'."
input nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp {
  _and: [nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp!]
  _not: nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp
  _or: [nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp!]
  buy_it_now_price: numeric_comparison_exp
  coin_type: String_comparison_exp
  collection_id: String_comparison_exp
  contract_address: String_comparison_exp
  current_bid_price: numeric_comparison_exp
  current_bidder: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  expiration_time: numeric_comparison_exp
  fee_schedule_id: String_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_timestamp: timestamptz_comparison_exp
  last_transaction_version: bigint_comparison_exp
  listing_id: String_comparison_exp
  marketplace: String_comparison_exp
  seller: String_comparison_exp
  starting_bid_price: numeric_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_standard: String_comparison_exp
}

"Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_auctions\"."
input nft_marketplace_v2_current_nft_marketplace_auctions_order_by {
  buy_it_now_price: order_by
  coin_type: order_by
  collection_id: order_by
  contract_address: order_by
  current_bid_price: order_by
  current_bidder: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  expiration_time: order_by
  fee_schedule_id: order_by
  is_deleted: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  listing_id: order_by
  marketplace: order_by
  seller: order_by
  starting_bid_price: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
}

"select columns of table \"nft_marketplace_v2.current_nft_marketplace_auctions\""
enum nft_marketplace_v2_current_nft_marketplace_auctions_select_column {
  "column name"
  buy_it_now_price
  "column name"
  coin_type
  "column name"
  collection_id
  "column name"
  contract_address
  "column name"
  current_bid_price
  "column name"
  current_bidder
  "column name"
  entry_function_id_str
  "column name"
  expiration_time
  "column name"
  fee_schedule_id
  "column name"
  is_deleted
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  listing_id
  "column name"
  marketplace
  "column name"
  seller
  "column name"
  starting_bid_price
  "column name"
  token_amount
  "column name"
  token_data_id
  "column name"
  token_standard
}

"Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_auctions\""
input nft_marketplace_v2_current_nft_marketplace_auctions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_marketplace_v2_current_nft_marketplace_auctions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_marketplace_v2_current_nft_marketplace_auctions_stream_cursor_value_input {
  buy_it_now_price: numeric
  coin_type: String
  collection_id: String
  contract_address: String
  current_bid_price: numeric
  current_bidder: String
  entry_function_id_str: String
  expiration_time: numeric
  fee_schedule_id: String
  is_deleted: Boolean
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  listing_id: String
  marketplace: String
  seller: String
  starting_bid_price: numeric
  token_amount: numeric
  token_data_id: String
  token_standard: String
}

"columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_collection_offers\""
type nft_marketplace_v2_current_nft_marketplace_collection_offers {
  buyer: String!
  coin_type: String
  collection_id: String!
  collection_offer_id: String!
  contract_address: String!
  "An object relationship"
  current_collection_v2: current_collections_v2
  entry_function_id_str: String!
  expiration_time: numeric!
  fee_schedule_id: String!
  is_deleted: Boolean!
  item_price: numeric!
  last_transaction_timestamp: timestamptz!
  last_transaction_version: bigint!
  marketplace: String!
  remaining_token_amount: numeric!
  token_standard: String!
}

"Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_collection_offers\". All fields are combined with a logical 'AND'."
input nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp {
  _and: [nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp!]
  _not: nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp
  _or: [nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp!]
  buyer: String_comparison_exp
  coin_type: String_comparison_exp
  collection_id: String_comparison_exp
  collection_offer_id: String_comparison_exp
  contract_address: String_comparison_exp
  current_collection_v2: current_collections_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  expiration_time: numeric_comparison_exp
  fee_schedule_id: String_comparison_exp
  is_deleted: Boolean_comparison_exp
  item_price: numeric_comparison_exp
  last_transaction_timestamp: timestamptz_comparison_exp
  last_transaction_version: bigint_comparison_exp
  marketplace: String_comparison_exp
  remaining_token_amount: numeric_comparison_exp
  token_standard: String_comparison_exp
}

"Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_collection_offers\"."
input nft_marketplace_v2_current_nft_marketplace_collection_offers_order_by {
  buyer: order_by
  coin_type: order_by
  collection_id: order_by
  collection_offer_id: order_by
  contract_address: order_by
  current_collection_v2: current_collections_v2_order_by
  entry_function_id_str: order_by
  expiration_time: order_by
  fee_schedule_id: order_by
  is_deleted: order_by
  item_price: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  marketplace: order_by
  remaining_token_amount: order_by
  token_standard: order_by
}

"select columns of table \"nft_marketplace_v2.current_nft_marketplace_collection_offers\""
enum nft_marketplace_v2_current_nft_marketplace_collection_offers_select_column {
  "column name"
  buyer
  "column name"
  coin_type
  "column name"
  collection_id
  "column name"
  collection_offer_id
  "column name"
  contract_address
  "column name"
  entry_function_id_str
  "column name"
  expiration_time
  "column name"
  fee_schedule_id
  "column name"
  is_deleted
  "column name"
  item_price
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  marketplace
  "column name"
  remaining_token_amount
  "column name"
  token_standard
}

"Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_collection_offers\""
input nft_marketplace_v2_current_nft_marketplace_collection_offers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_marketplace_v2_current_nft_marketplace_collection_offers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_marketplace_v2_current_nft_marketplace_collection_offers_stream_cursor_value_input {
  buyer: String
  coin_type: String
  collection_id: String
  collection_offer_id: String
  contract_address: String
  entry_function_id_str: String
  expiration_time: numeric
  fee_schedule_id: String
  is_deleted: Boolean
  item_price: numeric
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  marketplace: String
  remaining_token_amount: numeric
  token_standard: String
}

"columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_listings\""
type nft_marketplace_v2_current_nft_marketplace_listings {
  coin_type: String
  collection_id: String!
  contract_address: String!
  "An object relationship"
  current_token_data: current_token_datas_v2
  entry_function_id_str: String!
  fee_schedule_id: String!
  is_deleted: Boolean!
  last_transaction_timestamp: timestamptz!
  last_transaction_version: bigint!
  listing_id: String!
  marketplace: String!
  price: numeric!
  seller: String!
  token_amount: numeric!
  token_data_id: String!
  token_standard: String!
}

"aggregated selection of \"nft_marketplace_v2.current_nft_marketplace_listings\""
type nft_marketplace_v2_current_nft_marketplace_listings_aggregate {
  aggregate: nft_marketplace_v2_current_nft_marketplace_listings_aggregate_fields
  nodes: [nft_marketplace_v2_current_nft_marketplace_listings!]!
}

"aggregate fields of \"nft_marketplace_v2.current_nft_marketplace_listings\""
type nft_marketplace_v2_current_nft_marketplace_listings_aggregate_fields {
  avg: nft_marketplace_v2_current_nft_marketplace_listings_avg_fields
  count(columns: [nft_marketplace_v2_current_nft_marketplace_listings_select_column!] distinct: Boolean): Int!
  max: nft_marketplace_v2_current_nft_marketplace_listings_max_fields
  min: nft_marketplace_v2_current_nft_marketplace_listings_min_fields
  stddev: nft_marketplace_v2_current_nft_marketplace_listings_stddev_fields
  stddev_pop: nft_marketplace_v2_current_nft_marketplace_listings_stddev_pop_fields
  stddev_samp: nft_marketplace_v2_current_nft_marketplace_listings_stddev_samp_fields
  sum: nft_marketplace_v2_current_nft_marketplace_listings_sum_fields
  var_pop: nft_marketplace_v2_current_nft_marketplace_listings_var_pop_fields
  var_samp: nft_marketplace_v2_current_nft_marketplace_listings_var_samp_fields
  variance: nft_marketplace_v2_current_nft_marketplace_listings_variance_fields
}

"aggregate avg on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_avg_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_listings\". All fields are combined with a logical 'AND'."
input nft_marketplace_v2_current_nft_marketplace_listings_bool_exp {
  _and: [nft_marketplace_v2_current_nft_marketplace_listings_bool_exp!]
  _not: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp
  _or: [nft_marketplace_v2_current_nft_marketplace_listings_bool_exp!]
  coin_type: String_comparison_exp
  collection_id: String_comparison_exp
  contract_address: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  fee_schedule_id: String_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_timestamp: timestamptz_comparison_exp
  last_transaction_version: bigint_comparison_exp
  listing_id: String_comparison_exp
  marketplace: String_comparison_exp
  price: numeric_comparison_exp
  seller: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_standard: String_comparison_exp
}

"aggregate max on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_max_fields {
  coin_type: String
  collection_id: String
  contract_address: String
  entry_function_id_str: String
  fee_schedule_id: String
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  listing_id: String
  marketplace: String
  price: numeric
  seller: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
}

"aggregate min on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_min_fields {
  coin_type: String
  collection_id: String
  contract_address: String
  entry_function_id_str: String
  fee_schedule_id: String
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  listing_id: String
  marketplace: String
  price: numeric
  seller: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
}

"Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_listings\"."
input nft_marketplace_v2_current_nft_marketplace_listings_order_by {
  coin_type: order_by
  collection_id: order_by
  contract_address: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  fee_schedule_id: order_by
  is_deleted: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  listing_id: order_by
  marketplace: order_by
  price: order_by
  seller: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
}

"select columns of table \"nft_marketplace_v2.current_nft_marketplace_listings\""
enum nft_marketplace_v2_current_nft_marketplace_listings_select_column {
  "column name"
  coin_type
  "column name"
  collection_id
  "column name"
  contract_address
  "column name"
  entry_function_id_str
  "column name"
  fee_schedule_id
  "column name"
  is_deleted
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  listing_id
  "column name"
  marketplace
  "column name"
  price
  "column name"
  seller
  "column name"
  token_amount
  "column name"
  token_data_id
  "column name"
  token_standard
}

"aggregate stddev on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_stddev_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"aggregate stddev_pop on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_stddev_pop_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"aggregate stddev_samp on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_stddev_samp_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_listings\""
input nft_marketplace_v2_current_nft_marketplace_listings_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_marketplace_v2_current_nft_marketplace_listings_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_marketplace_v2_current_nft_marketplace_listings_stream_cursor_value_input {
  coin_type: String
  collection_id: String
  contract_address: String
  entry_function_id_str: String
  fee_schedule_id: String
  is_deleted: Boolean
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  listing_id: String
  marketplace: String
  price: numeric
  seller: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
}

"aggregate sum on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_sum_fields {
  last_transaction_version: bigint
  price: numeric
  token_amount: numeric
}

"aggregate var_pop on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_var_pop_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"aggregate var_samp on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_var_samp_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"aggregate variance on columns"
type nft_marketplace_v2_current_nft_marketplace_listings_variance_fields {
  last_transaction_version: Float
  price: Float
  token_amount: Float
}

"columns and relationships of \"nft_marketplace_v2.current_nft_marketplace_token_offers\""
type nft_marketplace_v2_current_nft_marketplace_token_offers {
  buyer: String!
  coin_type: String
  collection_id: String!
  contract_address: String!
  "An object relationship"
  current_token_data: current_token_datas_v2
  entry_function_id_str: String!
  expiration_time: numeric!
  fee_schedule_id: String!
  is_deleted: Boolean!
  last_transaction_timestamp: timestamptz!
  last_transaction_version: bigint!
  marketplace: String!
  offer_id: String!
  price: numeric!
  token_amount: numeric!
  token_data_id: String!
  token_standard: String!
}

"Boolean expression to filter rows from the table \"nft_marketplace_v2.current_nft_marketplace_token_offers\". All fields are combined with a logical 'AND'."
input nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp {
  _and: [nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp!]
  _not: nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp
  _or: [nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp!]
  buyer: String_comparison_exp
  coin_type: String_comparison_exp
  collection_id: String_comparison_exp
  contract_address: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  expiration_time: numeric_comparison_exp
  fee_schedule_id: String_comparison_exp
  is_deleted: Boolean_comparison_exp
  last_transaction_timestamp: timestamptz_comparison_exp
  last_transaction_version: bigint_comparison_exp
  marketplace: String_comparison_exp
  offer_id: String_comparison_exp
  price: numeric_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_standard: String_comparison_exp
}

"Ordering options when selecting data from \"nft_marketplace_v2.current_nft_marketplace_token_offers\"."
input nft_marketplace_v2_current_nft_marketplace_token_offers_order_by {
  buyer: order_by
  coin_type: order_by
  collection_id: order_by
  contract_address: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  expiration_time: order_by
  fee_schedule_id: order_by
  is_deleted: order_by
  last_transaction_timestamp: order_by
  last_transaction_version: order_by
  marketplace: order_by
  offer_id: order_by
  price: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
}

"select columns of table \"nft_marketplace_v2.current_nft_marketplace_token_offers\""
enum nft_marketplace_v2_current_nft_marketplace_token_offers_select_column {
  "column name"
  buyer
  "column name"
  coin_type
  "column name"
  collection_id
  "column name"
  contract_address
  "column name"
  entry_function_id_str
  "column name"
  expiration_time
  "column name"
  fee_schedule_id
  "column name"
  is_deleted
  "column name"
  last_transaction_timestamp
  "column name"
  last_transaction_version
  "column name"
  marketplace
  "column name"
  offer_id
  "column name"
  price
  "column name"
  token_amount
  "column name"
  token_data_id
  "column name"
  token_standard
}

"Streaming cursor of the table \"nft_marketplace_v2_current_nft_marketplace_token_offers\""
input nft_marketplace_v2_current_nft_marketplace_token_offers_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_marketplace_v2_current_nft_marketplace_token_offers_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_marketplace_v2_current_nft_marketplace_token_offers_stream_cursor_value_input {
  buyer: String
  coin_type: String
  collection_id: String
  contract_address: String
  entry_function_id_str: String
  expiration_time: numeric
  fee_schedule_id: String
  is_deleted: Boolean
  last_transaction_timestamp: timestamptz
  last_transaction_version: bigint
  marketplace: String
  offer_id: String
  price: numeric
  token_amount: numeric
  token_data_id: String
  token_standard: String
}

"columns and relationships of \"nft_marketplace_v2.nft_marketplace_activities\""
type nft_marketplace_v2_nft_marketplace_activities {
  buyer: String
  coin_type: String
  collection_id: String!
  collection_name: String!
  contract_address: String!
  creator_address: String!
  "An object relationship"
  current_token_data: current_token_datas_v2
  entry_function_id_str: String!
  event_index: bigint!
  event_type: String!
  fee_schedule_id: String!
  marketplace: String!
  offer_or_listing_id: String!
  price: numeric!
  property_version: String
  seller: String
  token_amount: numeric!
  token_data_id: String
  token_name: String
  token_standard: String!
  transaction_timestamp: timestamptz!
  transaction_version: bigint!
}

"Boolean expression to filter rows from the table \"nft_marketplace_v2.nft_marketplace_activities\". All fields are combined with a logical 'AND'."
input nft_marketplace_v2_nft_marketplace_activities_bool_exp {
  _and: [nft_marketplace_v2_nft_marketplace_activities_bool_exp!]
  _not: nft_marketplace_v2_nft_marketplace_activities_bool_exp
  _or: [nft_marketplace_v2_nft_marketplace_activities_bool_exp!]
  buyer: String_comparison_exp
  coin_type: String_comparison_exp
  collection_id: String_comparison_exp
  collection_name: String_comparison_exp
  contract_address: String_comparison_exp
  creator_address: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  event_index: bigint_comparison_exp
  event_type: String_comparison_exp
  fee_schedule_id: String_comparison_exp
  marketplace: String_comparison_exp
  offer_or_listing_id: String_comparison_exp
  price: numeric_comparison_exp
  property_version: String_comparison_exp
  seller: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_name: String_comparison_exp
  token_standard: String_comparison_exp
  transaction_timestamp: timestamptz_comparison_exp
  transaction_version: bigint_comparison_exp
}

"Ordering options when selecting data from \"nft_marketplace_v2.nft_marketplace_activities\"."
input nft_marketplace_v2_nft_marketplace_activities_order_by {
  buyer: order_by
  coin_type: order_by
  collection_id: order_by
  collection_name: order_by
  contract_address: order_by
  creator_address: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  event_index: order_by
  event_type: order_by
  fee_schedule_id: order_by
  marketplace: order_by
  offer_or_listing_id: order_by
  price: order_by
  property_version: order_by
  seller: order_by
  token_amount: order_by
  token_data_id: order_by
  token_name: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"nft_marketplace_v2.nft_marketplace_activities\""
enum nft_marketplace_v2_nft_marketplace_activities_select_column {
  "column name"
  buyer
  "column name"
  coin_type
  "column name"
  collection_id
  "column name"
  collection_name
  "column name"
  contract_address
  "column name"
  creator_address
  "column name"
  entry_function_id_str
  "column name"
  event_index
  "column name"
  event_type
  "column name"
  fee_schedule_id
  "column name"
  marketplace
  "column name"
  offer_or_listing_id
  "column name"
  price
  "column name"
  property_version
  "column name"
  seller
  "column name"
  token_amount
  "column name"
  token_data_id
  "column name"
  token_name
  "column name"
  token_standard
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"Streaming cursor of the table \"nft_marketplace_v2_nft_marketplace_activities\""
input nft_marketplace_v2_nft_marketplace_activities_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_marketplace_v2_nft_marketplace_activities_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_marketplace_v2_nft_marketplace_activities_stream_cursor_value_input {
  buyer: String
  coin_type: String
  collection_id: String
  collection_name: String
  contract_address: String
  creator_address: String
  entry_function_id_str: String
  event_index: bigint
  event_type: String
  fee_schedule_id: String
  marketplace: String
  offer_or_listing_id: String
  price: numeric
  property_version: String
  seller: String
  token_amount: numeric
  token_data_id: String
  token_name: String
  token_standard: String
  transaction_timestamp: timestamptz
  transaction_version: bigint
}

"columns and relationships of \"nft_metadata_crawler.parsed_asset_uris\""
type nft_metadata_crawler_parsed_asset_uris {
  animation_optimizer_retry_count: Int!
  asset_uri: String!
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int!
  json_parser_retry_count: Int!
  raw_animation_uri: String
  raw_image_uri: String
}

"Boolean expression to filter rows from the table \"nft_metadata_crawler.parsed_asset_uris\". All fields are combined with a logical 'AND'."
input nft_metadata_crawler_parsed_asset_uris_bool_exp {
  _and: [nft_metadata_crawler_parsed_asset_uris_bool_exp!]
  _not: nft_metadata_crawler_parsed_asset_uris_bool_exp
  _or: [nft_metadata_crawler_parsed_asset_uris_bool_exp!]
  animation_optimizer_retry_count: Int_comparison_exp
  asset_uri: String_comparison_exp
  cdn_animation_uri: String_comparison_exp
  cdn_image_uri: String_comparison_exp
  cdn_json_uri: String_comparison_exp
  image_optimizer_retry_count: Int_comparison_exp
  json_parser_retry_count: Int_comparison_exp
  raw_animation_uri: String_comparison_exp
  raw_image_uri: String_comparison_exp
}

"Ordering options when selecting data from \"nft_metadata_crawler.parsed_asset_uris\"."
input nft_metadata_crawler_parsed_asset_uris_order_by {
  animation_optimizer_retry_count: order_by
  asset_uri: order_by
  cdn_animation_uri: order_by
  cdn_image_uri: order_by
  cdn_json_uri: order_by
  image_optimizer_retry_count: order_by
  json_parser_retry_count: order_by
  raw_animation_uri: order_by
  raw_image_uri: order_by
}

"select columns of table \"nft_metadata_crawler.parsed_asset_uris\""
enum nft_metadata_crawler_parsed_asset_uris_select_column {
  "column name"
  animation_optimizer_retry_count
  "column name"
  asset_uri
  "column name"
  cdn_animation_uri
  "column name"
  cdn_image_uri
  "column name"
  cdn_json_uri
  "column name"
  image_optimizer_retry_count
  "column name"
  json_parser_retry_count
  "column name"
  raw_animation_uri
  "column name"
  raw_image_uri
}

"Streaming cursor of the table \"nft_metadata_crawler_parsed_asset_uris\""
input nft_metadata_crawler_parsed_asset_uris_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: nft_metadata_crawler_parsed_asset_uris_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input nft_metadata_crawler_parsed_asset_uris_stream_cursor_value_input {
  animation_optimizer_retry_count: Int
  asset_uri: String
  cdn_animation_uri: String
  cdn_image_uri: String
  cdn_json_uri: String
  image_optimizer_retry_count: Int
  json_parser_retry_count: Int
  raw_animation_uri: String
  raw_image_uri: String
}

"columns and relationships of \"num_active_delegator_per_pool\""
type num_active_delegator_per_pool {
  num_active_delegator: bigint
  pool_address: String
}

"Boolean expression to filter rows from the table \"num_active_delegator_per_pool\". All fields are combined with a logical 'AND'."
input num_active_delegator_per_pool_bool_exp {
  _and: [num_active_delegator_per_pool_bool_exp!]
  _not: num_active_delegator_per_pool_bool_exp
  _or: [num_active_delegator_per_pool_bool_exp!]
  num_active_delegator: bigint_comparison_exp
  pool_address: String_comparison_exp
}

"Ordering options when selecting data from \"num_active_delegator_per_pool\"."
input num_active_delegator_per_pool_order_by {
  num_active_delegator: order_by
  pool_address: order_by
}

"select columns of table \"num_active_delegator_per_pool\""
enum num_active_delegator_per_pool_select_column {
  "column name"
  num_active_delegator
  "column name"
  pool_address
}

"Streaming cursor of the table \"num_active_delegator_per_pool\""
input num_active_delegator_per_pool_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: num_active_delegator_per_pool_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input num_active_delegator_per_pool_stream_cursor_value_input {
  num_active_delegator: bigint
  pool_address: String
}

scalar numeric

"Boolean expression to compare columns of type \"numeric\". All fields are combined with logical 'AND'."
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

"column ordering options"
enum order_by {
  "in ascending order, nulls last"
  asc
  "in ascending order, nulls first"
  asc_nulls_first
  "in ascending order, nulls last"
  asc_nulls_last
  "in descending order, nulls first"
  desc
  "in descending order, nulls first"
  desc_nulls_first
  "in descending order, nulls last"
  desc_nulls_last
}

"columns and relationships of \"processor_status\""
type processor_status {
  last_success_version: bigint!
  last_transaction_timestamp: timestamp
  last_updated: timestamp!
  processor: String!
}

"Boolean expression to filter rows from the table \"processor_status\". All fields are combined with a logical 'AND'."
input processor_status_bool_exp {
  _and: [processor_status_bool_exp!]
  _not: processor_status_bool_exp
  _or: [processor_status_bool_exp!]
  last_success_version: bigint_comparison_exp
  last_transaction_timestamp: timestamp_comparison_exp
  last_updated: timestamp_comparison_exp
  processor: String_comparison_exp
}

"Ordering options when selecting data from \"processor_status\"."
input processor_status_order_by {
  last_success_version: order_by
  last_transaction_timestamp: order_by
  last_updated: order_by
  processor: order_by
}

"select columns of table \"processor_status\""
enum processor_status_select_column {
  "column name"
  last_success_version
  "column name"
  last_transaction_timestamp
  "column name"
  last_updated
  "column name"
  processor
}

"Streaming cursor of the table \"processor_status\""
input processor_status_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: processor_status_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input processor_status_stream_cursor_value_input {
  last_success_version: bigint
  last_transaction_timestamp: timestamp
  last_updated: timestamp
  processor: String
}

"columns and relationships of \"proposal_votes\""
type proposal_votes {
  num_votes: numeric!
  proposal_id: bigint!
  should_pass: Boolean!
  staking_pool_address: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  voter_address: String!
}

"aggregated selection of \"proposal_votes\""
type proposal_votes_aggregate {
  aggregate: proposal_votes_aggregate_fields
  nodes: [proposal_votes!]!
}

"aggregate fields of \"proposal_votes\""
type proposal_votes_aggregate_fields {
  avg: proposal_votes_avg_fields
  count(columns: [proposal_votes_select_column!] distinct: Boolean): Int!
  max: proposal_votes_max_fields
  min: proposal_votes_min_fields
  stddev: proposal_votes_stddev_fields
  stddev_pop: proposal_votes_stddev_pop_fields
  stddev_samp: proposal_votes_stddev_samp_fields
  sum: proposal_votes_sum_fields
  var_pop: proposal_votes_var_pop_fields
  var_samp: proposal_votes_var_samp_fields
  variance: proposal_votes_variance_fields
}

"aggregate avg on columns"
type proposal_votes_avg_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"Boolean expression to filter rows from the table \"proposal_votes\". All fields are combined with a logical 'AND'."
input proposal_votes_bool_exp {
  _and: [proposal_votes_bool_exp!]
  _not: proposal_votes_bool_exp
  _or: [proposal_votes_bool_exp!]
  num_votes: numeric_comparison_exp
  proposal_id: bigint_comparison_exp
  should_pass: Boolean_comparison_exp
  staking_pool_address: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  voter_address: String_comparison_exp
}

"aggregate max on columns"
type proposal_votes_max_fields {
  num_votes: numeric
  proposal_id: bigint
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"aggregate min on columns"
type proposal_votes_min_fields {
  num_votes: numeric
  proposal_id: bigint
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"Ordering options when selecting data from \"proposal_votes\"."
input proposal_votes_order_by {
  num_votes: order_by
  proposal_id: order_by
  should_pass: order_by
  staking_pool_address: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  voter_address: order_by
}

"select columns of table \"proposal_votes\""
enum proposal_votes_select_column {
  "column name"
  num_votes
  "column name"
  proposal_id
  "column name"
  should_pass
  "column name"
  staking_pool_address
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  voter_address
}

"aggregate stddev on columns"
type proposal_votes_stddev_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"aggregate stddev_pop on columns"
type proposal_votes_stddev_pop_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"aggregate stddev_samp on columns"
type proposal_votes_stddev_samp_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"Streaming cursor of the table \"proposal_votes\""
input proposal_votes_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: proposal_votes_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input proposal_votes_stream_cursor_value_input {
  num_votes: numeric
  proposal_id: bigint
  should_pass: Boolean
  staking_pool_address: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  voter_address: String
}

"aggregate sum on columns"
type proposal_votes_sum_fields {
  num_votes: numeric
  proposal_id: bigint
  transaction_version: bigint
}

"aggregate var_pop on columns"
type proposal_votes_var_pop_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"aggregate var_samp on columns"
type proposal_votes_var_samp_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

"aggregate variance on columns"
type proposal_votes_variance_fields {
  num_votes: Float
  proposal_id: Float
  transaction_version: Float
}

type query_root {
  "fetch data from the table: \"account_transactions\""
  account_transactions("distinct select on columns" distinct_on: [account_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_transactions_order_by!] "filter the rows returned" where: account_transactions_bool_exp): [account_transactions!]!
  "fetch aggregated fields from the table: \"account_transactions\""
  account_transactions_aggregate("distinct select on columns" distinct_on: [account_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_transactions_order_by!] "filter the rows returned" where: account_transactions_bool_exp): account_transactions_aggregate!
  "fetch data from the table: \"account_transactions\" using primary key columns"
  account_transactions_by_pk(account_address: String! transaction_version: bigint!): account_transactions
  "fetch data from the table: \"address_events_summary\""
  address_events_summary("distinct select on columns" distinct_on: [address_events_summary_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_events_summary_order_by!] "filter the rows returned" where: address_events_summary_bool_exp): [address_events_summary!]!
  "fetch data from the table: \"address_version_from_events\""
  address_version_from_events("distinct select on columns" distinct_on: [address_version_from_events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_events_order_by!] "filter the rows returned" where: address_version_from_events_bool_exp): [address_version_from_events!]!
  "fetch aggregated fields from the table: \"address_version_from_events\""
  address_version_from_events_aggregate("distinct select on columns" distinct_on: [address_version_from_events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_events_order_by!] "filter the rows returned" where: address_version_from_events_bool_exp): address_version_from_events_aggregate!
  "fetch data from the table: \"legacy_migration_v1.address_version_from_move_resources\""
  address_version_from_move_resources("distinct select on columns" distinct_on: [address_version_from_move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_move_resources_order_by!] "filter the rows returned" where: address_version_from_move_resources_bool_exp): [address_version_from_move_resources!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.address_version_from_move_resources\""
  address_version_from_move_resources_aggregate("distinct select on columns" distinct_on: [address_version_from_move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_move_resources_order_by!] "filter the rows returned" where: address_version_from_move_resources_bool_exp): address_version_from_move_resources_aggregate!
  "fetch data from the table: \"block_metadata_transactions\""
  block_metadata_transactions("distinct select on columns" distinct_on: [block_metadata_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_metadata_transactions_order_by!] "filter the rows returned" where: block_metadata_transactions_bool_exp): [block_metadata_transactions!]!
  "fetch data from the table: \"block_metadata_transactions\" using primary key columns"
  block_metadata_transactions_by_pk(version: bigint!): block_metadata_transactions
  "An array relationship"
  coin_activities("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "An aggregate relationship"
  coin_activities_aggregate("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): coin_activities_aggregate!
  "fetch data from the table: \"legacy_migration_v1.coin_balances\""
  coin_balances("distinct select on columns" distinct_on: [coin_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_balances_order_by!] "filter the rows returned" where: coin_balances_bool_exp): [coin_balances!]!
  "fetch data from the table: \"legacy_migration_v1.coin_infos\""
  coin_infos("distinct select on columns" distinct_on: [coin_infos_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_infos_order_by!] "filter the rows returned" where: coin_infos_bool_exp): [coin_infos!]!
  "fetch data from the table: \"coin_supply\""
  coin_supply("distinct select on columns" distinct_on: [coin_supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_supply_order_by!] "filter the rows returned" where: coin_supply_bool_exp): [coin_supply!]!
  "fetch data from the table: \"coin_supply\" using primary key columns"
  coin_supply_by_pk(coin_type_hash: String! transaction_version: bigint!): coin_supply
  "fetch data from the table: \"legacy_migration_v1.collection_datas\""
  collection_datas("distinct select on columns" distinct_on: [collection_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [collection_datas_order_by!] "filter the rows returned" where: collection_datas_bool_exp): [collection_datas!]!
  "fetch data from the table: \"legacy_migration_v1.current_ans_lookup\""
  current_ans_lookup("distinct select on columns" distinct_on: [current_ans_lookup_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_ans_lookup_order_by!] "filter the rows returned" where: current_ans_lookup_bool_exp): [current_ans_lookup!]!
  "fetch data from the table: \"current_ans_lookup_v2\""
  current_ans_lookup_v2("distinct select on columns" distinct_on: [current_ans_lookup_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_ans_lookup_v2_order_by!] "filter the rows returned" where: current_ans_lookup_v2_bool_exp): [current_ans_lookup_v2!]!
  "fetch data from the table: \"current_ans_lookup_v2\" using primary key columns"
  current_ans_lookup_v2_by_pk(domain: String! subdomain: String! token_standard: String!): current_ans_lookup_v2
  "fetch data from the table: \"current_aptos_names\""
  current_aptos_names("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "fetch aggregated fields from the table: \"current_aptos_names\""
  current_aptos_names_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  "fetch data from the table: \"legacy_migration_v1.current_coin_balances\""
  current_coin_balances("distinct select on columns" distinct_on: [current_coin_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_coin_balances_order_by!] "filter the rows returned" where: current_coin_balances_bool_exp): [current_coin_balances!]!
  "fetch data from the table: \"legacy_migration_v1.current_collection_datas\""
  current_collection_datas("distinct select on columns" distinct_on: [current_collection_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_datas_order_by!] "filter the rows returned" where: current_collection_datas_bool_exp): [current_collection_datas!]!
  "fetch data from the table: \"current_collection_ownership_v2_view\""
  current_collection_ownership_v2_view("distinct select on columns" distinct_on: [current_collection_ownership_v2_view_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_ownership_v2_view_order_by!] "filter the rows returned" where: current_collection_ownership_v2_view_bool_exp): [current_collection_ownership_v2_view!]!
  "fetch aggregated fields from the table: \"current_collection_ownership_v2_view\""
  current_collection_ownership_v2_view_aggregate("distinct select on columns" distinct_on: [current_collection_ownership_v2_view_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_ownership_v2_view_order_by!] "filter the rows returned" where: current_collection_ownership_v2_view_bool_exp): current_collection_ownership_v2_view_aggregate!
  "fetch data from the table: \"current_collections_v2\""
  current_collections_v2("distinct select on columns" distinct_on: [current_collections_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collections_v2_order_by!] "filter the rows returned" where: current_collections_v2_bool_exp): [current_collections_v2!]!
  "fetch data from the table: \"current_collections_v2\" using primary key columns"
  current_collections_v2_by_pk(collection_id: String!): current_collections_v2
  "fetch data from the table: \"current_delegated_staking_pool_balances\""
  current_delegated_staking_pool_balances("distinct select on columns" distinct_on: [current_delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegated_staking_pool_balances_order_by!] "filter the rows returned" where: current_delegated_staking_pool_balances_bool_exp): [current_delegated_staking_pool_balances!]!
  "fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns"
  current_delegated_staking_pool_balances_by_pk(staking_pool_address: String!): current_delegated_staking_pool_balances
  "fetch data from the table: \"current_delegated_voter\""
  current_delegated_voter("distinct select on columns" distinct_on: [current_delegated_voter_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegated_voter_order_by!] "filter the rows returned" where: current_delegated_voter_bool_exp): [current_delegated_voter!]!
  "fetch data from the table: \"current_delegated_voter\" using primary key columns"
  current_delegated_voter_by_pk(delegation_pool_address: String! delegator_address: String!): current_delegated_voter
  "fetch data from the table: \"current_delegator_balances\""
  current_delegator_balances("distinct select on columns" distinct_on: [current_delegator_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegator_balances_order_by!] "filter the rows returned" where: current_delegator_balances_bool_exp): [current_delegator_balances!]!
  "fetch data from the table: \"current_delegator_balances\" using primary key columns"
  current_delegator_balances_by_pk(delegator_address: String! pool_address: String! pool_type: String! table_handle: String!): current_delegator_balances
  "fetch data from the table: \"current_fungible_asset_balances\""
  current_fungible_asset_balances("distinct select on columns" distinct_on: [current_fungible_asset_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_fungible_asset_balances_order_by!] "filter the rows returned" where: current_fungible_asset_balances_bool_exp): [current_fungible_asset_balances!]!
  "fetch aggregated fields from the table: \"current_fungible_asset_balances\""
  current_fungible_asset_balances_aggregate("distinct select on columns" distinct_on: [current_fungible_asset_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_fungible_asset_balances_order_by!] "filter the rows returned" where: current_fungible_asset_balances_bool_exp): current_fungible_asset_balances_aggregate!
  "fetch data from the table: \"current_fungible_asset_balances\" using primary key columns"
  current_fungible_asset_balances_by_pk(storage_id: String!): current_fungible_asset_balances
  "fetch data from the table: \"current_objects\""
  current_objects("distinct select on columns" distinct_on: [current_objects_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_objects_order_by!] "filter the rows returned" where: current_objects_bool_exp): [current_objects!]!
  "fetch data from the table: \"current_objects\" using primary key columns"
  current_objects_by_pk(object_address: String!): current_objects
  "fetch data from the table: \"current_staking_pool_voter\""
  current_staking_pool_voter("distinct select on columns" distinct_on: [current_staking_pool_voter_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_staking_pool_voter_order_by!] "filter the rows returned" where: current_staking_pool_voter_bool_exp): [current_staking_pool_voter!]!
  "fetch data from the table: \"current_staking_pool_voter\" using primary key columns"
  current_staking_pool_voter_by_pk(staking_pool_address: String!): current_staking_pool_voter
  "fetch data from the table: \"current_table_items\""
  current_table_items("distinct select on columns" distinct_on: [current_table_items_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_table_items_order_by!] "filter the rows returned" where: current_table_items_bool_exp): [current_table_items!]!
  "fetch data from the table: \"current_table_items\" using primary key columns"
  current_table_items_by_pk(key_hash: String! table_handle: String!): current_table_items
  "fetch data from the table: \"legacy_migration_v1.current_token_datas\""
  current_token_datas("distinct select on columns" distinct_on: [current_token_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_datas_order_by!] "filter the rows returned" where: current_token_datas_bool_exp): [current_token_datas!]!
  "fetch data from the table: \"current_token_datas_v2\""
  current_token_datas_v2("distinct select on columns" distinct_on: [current_token_datas_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_datas_v2_order_by!] "filter the rows returned" where: current_token_datas_v2_bool_exp): [current_token_datas_v2!]!
  "fetch data from the table: \"current_token_datas_v2\" using primary key columns"
  current_token_datas_v2_by_pk(token_data_id: String!): current_token_datas_v2
  "fetch data from the table: \"legacy_migration_v1.current_token_ownerships\""
  current_token_ownerships("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): [current_token_ownerships!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.current_token_ownerships\""
  current_token_ownerships_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): current_token_ownerships_aggregate!
  "fetch data from the table: \"current_token_ownerships_v2\""
  current_token_ownerships_v2("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): [current_token_ownerships_v2!]!
  "fetch aggregated fields from the table: \"current_token_ownerships_v2\""
  current_token_ownerships_v2_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): current_token_ownerships_v2_aggregate!
  "fetch data from the table: \"current_token_ownerships_v2\" using primary key columns"
  current_token_ownerships_v2_by_pk(owner_address: String! property_version_v1: numeric! storage_id: String! token_data_id: String!): current_token_ownerships_v2
  "fetch data from the table: \"current_token_pending_claims\""
  current_token_pending_claims("distinct select on columns" distinct_on: [current_token_pending_claims_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_pending_claims_order_by!] "filter the rows returned" where: current_token_pending_claims_bool_exp): [current_token_pending_claims!]!
  "fetch data from the table: \"current_token_pending_claims\" using primary key columns"
  current_token_pending_claims_by_pk(from_address: String! property_version: numeric! to_address: String! token_data_id_hash: String!): current_token_pending_claims
  "fetch data from the table: \"current_token_royalty_v1\""
  current_token_royalty_v1("distinct select on columns" distinct_on: [current_token_royalty_v1_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_royalty_v1_order_by!] "filter the rows returned" where: current_token_royalty_v1_bool_exp): [current_token_royalty_v1!]!
  "fetch data from the table: \"current_token_royalty_v1\" using primary key columns"
  current_token_royalty_v1_by_pk(token_data_id: String!): current_token_royalty_v1
  "An array relationship"
  delegated_staking_activities("distinct select on columns" distinct_on: [delegated_staking_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_activities_order_by!] "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "fetch data from the table: \"delegated_staking_activities\" using primary key columns"
  delegated_staking_activities_by_pk(event_index: bigint! transaction_version: bigint!): delegated_staking_activities
  "fetch data from the table: \"delegated_staking_pool_balances\""
  delegated_staking_pool_balances("distinct select on columns" distinct_on: [delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pool_balances_order_by!] "filter the rows returned" where: delegated_staking_pool_balances_bool_exp): [delegated_staking_pool_balances!]!
  "fetch aggregated fields from the table: \"delegated_staking_pool_balances\""
  delegated_staking_pool_balances_aggregate("distinct select on columns" distinct_on: [delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pool_balances_order_by!] "filter the rows returned" where: delegated_staking_pool_balances_bool_exp): delegated_staking_pool_balances_aggregate!
  "fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns"
  delegated_staking_pool_balances_by_pk(staking_pool_address: String! transaction_version: bigint!): delegated_staking_pool_balances
  "fetch data from the table: \"delegated_staking_pools\""
  delegated_staking_pools("distinct select on columns" distinct_on: [delegated_staking_pools_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pools_order_by!] "filter the rows returned" where: delegated_staking_pools_bool_exp): [delegated_staking_pools!]!
  "fetch data from the table: \"delegated_staking_pools\" using primary key columns"
  delegated_staking_pools_by_pk(staking_pool_address: String!): delegated_staking_pools
  "fetch data from the table: \"delegator_distinct_pool\""
  delegator_distinct_pool("distinct select on columns" distinct_on: [delegator_distinct_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegator_distinct_pool_order_by!] "filter the rows returned" where: delegator_distinct_pool_bool_exp): [delegator_distinct_pool!]!
  "fetch aggregated fields from the table: \"delegator_distinct_pool\""
  delegator_distinct_pool_aggregate("distinct select on columns" distinct_on: [delegator_distinct_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegator_distinct_pool_order_by!] "filter the rows returned" where: delegator_distinct_pool_bool_exp): delegator_distinct_pool_aggregate!
  "fetch data from the table: \"events\""
  events("distinct select on columns" distinct_on: [events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [events_order_by!] "filter the rows returned" where: events_bool_exp): [events!]!
  "fetch data from the table: \"events\" using primary key columns"
  events_by_pk(event_index: bigint! transaction_version: bigint!): events
  "An array relationship"
  fungible_asset_activities("distinct select on columns" distinct_on: [fungible_asset_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fungible_asset_activities_order_by!] "filter the rows returned" where: fungible_asset_activities_bool_exp): [fungible_asset_activities!]!
  "fetch data from the table: \"fungible_asset_activities\" using primary key columns"
  fungible_asset_activities_by_pk(event_index: bigint! transaction_version: bigint!): fungible_asset_activities
  "fetch data from the table: \"fungible_asset_metadata\""
  fungible_asset_metadata("distinct select on columns" distinct_on: [fungible_asset_metadata_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fungible_asset_metadata_order_by!] "filter the rows returned" where: fungible_asset_metadata_bool_exp): [fungible_asset_metadata!]!
  "fetch data from the table: \"fungible_asset_metadata\" using primary key columns"
  fungible_asset_metadata_by_pk(asset_type: String!): fungible_asset_metadata
  "fetch data from the table: \"indexer_status\""
  indexer_status("distinct select on columns" distinct_on: [indexer_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [indexer_status_order_by!] "filter the rows returned" where: indexer_status_bool_exp): [indexer_status!]!
  "fetch data from the table: \"indexer_status\" using primary key columns"
  indexer_status_by_pk(db: String!): indexer_status
  "fetch data from the table: \"ledger_infos\""
  ledger_infos("distinct select on columns" distinct_on: [ledger_infos_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [ledger_infos_order_by!] "filter the rows returned" where: ledger_infos_bool_exp): [ledger_infos!]!
  "fetch data from the table: \"ledger_infos\" using primary key columns"
  ledger_infos_by_pk(chain_id: bigint!): ledger_infos
  "fetch data from the table: \"legacy_migration_v1.move_resources\""
  move_resources("distinct select on columns" distinct_on: [move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [move_resources_order_by!] "filter the rows returned" where: move_resources_bool_exp): [move_resources!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.move_resources\""
  move_resources_aggregate("distinct select on columns" distinct_on: [move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [move_resources_order_by!] "filter the rows returned" where: move_resources_bool_exp): move_resources_aggregate!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\""
  nft_marketplace_v2_current_nft_marketplace_auctions("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_auctions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_auctions_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp): [nft_marketplace_v2_current_nft_marketplace_auctions!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_auctions_by_pk(listing_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_auctions
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\""
  nft_marketplace_v2_current_nft_marketplace_collection_offers("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_collection_offers_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_collection_offers_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_collection_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_collection_offers_by_pk(collection_id: String! collection_offer_id: String!): nft_marketplace_v2_current_nft_marketplace_collection_offers
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\""
  nft_marketplace_v2_current_nft_marketplace_listings("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_listings_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_listings_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp): [nft_marketplace_v2_current_nft_marketplace_listings!]!
  "fetch aggregated fields from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\""
  nft_marketplace_v2_current_nft_marketplace_listings_aggregate("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_listings_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_listings_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp): nft_marketplace_v2_current_nft_marketplace_listings_aggregate!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_listings_by_pk(listing_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_listings
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\""
  nft_marketplace_v2_current_nft_marketplace_token_offers("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_token_offers_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_token_offers_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_token_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_token_offers_by_pk(offer_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_token_offers
  "fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\""
  nft_marketplace_v2_nft_marketplace_activities("distinct select on columns" distinct_on: [nft_marketplace_v2_nft_marketplace_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_nft_marketplace_activities_order_by!] "filter the rows returned" where: nft_marketplace_v2_nft_marketplace_activities_bool_exp): [nft_marketplace_v2_nft_marketplace_activities!]!
  "fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" using primary key columns"
  nft_marketplace_v2_nft_marketplace_activities_by_pk(event_index: bigint! transaction_version: bigint!): nft_marketplace_v2_nft_marketplace_activities
  "fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\""
  nft_metadata_crawler_parsed_asset_uris("distinct select on columns" distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!] "filter the rows returned" where: nft_metadata_crawler_parsed_asset_uris_bool_exp): [nft_metadata_crawler_parsed_asset_uris!]!
  "fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns"
  nft_metadata_crawler_parsed_asset_uris_by_pk(asset_uri: String!): nft_metadata_crawler_parsed_asset_uris
  "fetch data from the table: \"num_active_delegator_per_pool\""
  num_active_delegator_per_pool("distinct select on columns" distinct_on: [num_active_delegator_per_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [num_active_delegator_per_pool_order_by!] "filter the rows returned" where: num_active_delegator_per_pool_bool_exp): [num_active_delegator_per_pool!]!
  "fetch data from the table: \"processor_status\""
  processor_status("distinct select on columns" distinct_on: [processor_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [processor_status_order_by!] "filter the rows returned" where: processor_status_bool_exp): [processor_status!]!
  "fetch data from the table: \"processor_status\" using primary key columns"
  processor_status_by_pk(processor: String!): processor_status
  "fetch data from the table: \"proposal_votes\""
  proposal_votes("distinct select on columns" distinct_on: [proposal_votes_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_votes_order_by!] "filter the rows returned" where: proposal_votes_bool_exp): [proposal_votes!]!
  "fetch aggregated fields from the table: \"proposal_votes\""
  proposal_votes_aggregate("distinct select on columns" distinct_on: [proposal_votes_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_votes_order_by!] "filter the rows returned" where: proposal_votes_bool_exp): proposal_votes_aggregate!
  "fetch data from the table: \"proposal_votes\" using primary key columns"
  proposal_votes_by_pk(proposal_id: bigint! transaction_version: bigint! voter_address: String!): proposal_votes
  "fetch data from the table: \"signatures\""
  signatures("distinct select on columns" distinct_on: [signatures_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [signatures_order_by!] "filter the rows returned" where: signatures_bool_exp): [signatures!]!
  "fetch data from the table: \"signatures\" using primary key columns"
  signatures_by_pk(is_sender_primary: Boolean! multi_agent_index: bigint! multi_sig_index: bigint! transaction_version: bigint!): signatures
  "fetch data from the table: \"table_items\""
  table_items("distinct select on columns" distinct_on: [table_items_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [table_items_order_by!] "filter the rows returned" where: table_items_bool_exp): [table_items!]!
  "fetch data from the table: \"table_items\" using primary key columns"
  table_items_by_pk(transaction_version: bigint! write_set_change_index: bigint!): table_items
  "fetch data from the table: \"table_metadatas\""
  table_metadatas("distinct select on columns" distinct_on: [table_metadatas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [table_metadatas_order_by!] "filter the rows returned" where: table_metadatas_bool_exp): [table_metadatas!]!
  "fetch data from the table: \"table_metadatas\" using primary key columns"
  table_metadatas_by_pk(handle: String!): table_metadatas
  "An array relationship"
  token_activities("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An aggregate relationship"
  token_activities_aggregate("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): token_activities_aggregate!
  "An array relationship"
  token_activities_v2("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "An aggregate relationship"
  token_activities_v2_aggregate("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): token_activities_v2_aggregate!
  "fetch data from the table: \"token_activities_v2\" using primary key columns"
  token_activities_v2_by_pk(event_index: bigint! transaction_version: bigint!): token_activities_v2
  "fetch data from the table: \"legacy_migration_v1.token_datas\""
  token_datas("distinct select on columns" distinct_on: [token_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_datas_order_by!] "filter the rows returned" where: token_datas_bool_exp): [token_datas!]!
  "fetch data from the table: \"legacy_migration_v1.token_ownerships\""
  token_ownerships("distinct select on columns" distinct_on: [token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_ownerships_order_by!] "filter the rows returned" where: token_ownerships_bool_exp): [token_ownerships!]!
  "fetch data from the table: \"legacy_migration_v1.tokens\""
  tokens("distinct select on columns" distinct_on: [tokens_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [tokens_order_by!] "filter the rows returned" where: tokens_bool_exp): [tokens!]!
  "fetch data from the table: \"user_transactions\""
  user_transactions("distinct select on columns" distinct_on: [user_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_transactions_order_by!] "filter the rows returned" where: user_transactions_bool_exp): [user_transactions!]!
  "fetch data from the table: \"user_transactions\" using primary key columns"
  user_transactions_by_pk(version: bigint!): user_transactions
}

"columns and relationships of \"signatures\""
type signatures {
  is_sender_primary: Boolean!
  multi_agent_index: bigint!
  multi_sig_index: bigint!
  public_key: String!
  public_key_indices("JSON select path" path: String): jsonb
  signature: String!
  signer: String!
  threshold: bigint!
  transaction_block_height: bigint!
  transaction_version: bigint!
  type: String!
}

"Boolean expression to filter rows from the table \"signatures\". All fields are combined with a logical 'AND'."
input signatures_bool_exp {
  _and: [signatures_bool_exp!]
  _not: signatures_bool_exp
  _or: [signatures_bool_exp!]
  is_sender_primary: Boolean_comparison_exp
  multi_agent_index: bigint_comparison_exp
  multi_sig_index: bigint_comparison_exp
  public_key: String_comparison_exp
  public_key_indices: jsonb_comparison_exp
  signature: String_comparison_exp
  signer: String_comparison_exp
  threshold: bigint_comparison_exp
  transaction_block_height: bigint_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"Ordering options when selecting data from \"signatures\"."
input signatures_order_by {
  is_sender_primary: order_by
  multi_agent_index: order_by
  multi_sig_index: order_by
  public_key: order_by
  public_key_indices: order_by
  signature: order_by
  signer: order_by
  threshold: order_by
  transaction_block_height: order_by
  transaction_version: order_by
  type: order_by
}

"select columns of table \"signatures\""
enum signatures_select_column {
  "column name"
  is_sender_primary
  "column name"
  multi_agent_index
  "column name"
  multi_sig_index
  "column name"
  public_key
  "column name"
  public_key_indices
  "column name"
  signature
  "column name"
  signer
  "column name"
  threshold
  "column name"
  transaction_block_height
  "column name"
  transaction_version
  "column name"
  type
}

"Streaming cursor of the table \"signatures\""
input signatures_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: signatures_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input signatures_stream_cursor_value_input {
  is_sender_primary: Boolean
  multi_agent_index: bigint
  multi_sig_index: bigint
  public_key: String
  public_key_indices: jsonb
  signature: String
  signer: String
  threshold: bigint
  transaction_block_height: bigint
  transaction_version: bigint
  type: String
}

type subscription_root {
  "fetch data from the table: \"account_transactions\""
  account_transactions("distinct select on columns" distinct_on: [account_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_transactions_order_by!] "filter the rows returned" where: account_transactions_bool_exp): [account_transactions!]!
  "fetch aggregated fields from the table: \"account_transactions\""
  account_transactions_aggregate("distinct select on columns" distinct_on: [account_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [account_transactions_order_by!] "filter the rows returned" where: account_transactions_bool_exp): account_transactions_aggregate!
  "fetch data from the table: \"account_transactions\" using primary key columns"
  account_transactions_by_pk(account_address: String! transaction_version: bigint!): account_transactions
  "fetch data from the table in a streaming manner: \"account_transactions\""
  account_transactions_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [account_transactions_stream_cursor_input]! "filter the rows returned" where: account_transactions_bool_exp): [account_transactions!]!
  "fetch data from the table: \"address_events_summary\""
  address_events_summary("distinct select on columns" distinct_on: [address_events_summary_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_events_summary_order_by!] "filter the rows returned" where: address_events_summary_bool_exp): [address_events_summary!]!
  "fetch data from the table in a streaming manner: \"address_events_summary\""
  address_events_summary_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [address_events_summary_stream_cursor_input]! "filter the rows returned" where: address_events_summary_bool_exp): [address_events_summary!]!
  "fetch data from the table: \"address_version_from_events\""
  address_version_from_events("distinct select on columns" distinct_on: [address_version_from_events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_events_order_by!] "filter the rows returned" where: address_version_from_events_bool_exp): [address_version_from_events!]!
  "fetch aggregated fields from the table: \"address_version_from_events\""
  address_version_from_events_aggregate("distinct select on columns" distinct_on: [address_version_from_events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_events_order_by!] "filter the rows returned" where: address_version_from_events_bool_exp): address_version_from_events_aggregate!
  "fetch data from the table in a streaming manner: \"address_version_from_events\""
  address_version_from_events_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [address_version_from_events_stream_cursor_input]! "filter the rows returned" where: address_version_from_events_bool_exp): [address_version_from_events!]!
  "fetch data from the table: \"legacy_migration_v1.address_version_from_move_resources\""
  address_version_from_move_resources("distinct select on columns" distinct_on: [address_version_from_move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_move_resources_order_by!] "filter the rows returned" where: address_version_from_move_resources_bool_exp): [address_version_from_move_resources!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.address_version_from_move_resources\""
  address_version_from_move_resources_aggregate("distinct select on columns" distinct_on: [address_version_from_move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [address_version_from_move_resources_order_by!] "filter the rows returned" where: address_version_from_move_resources_bool_exp): address_version_from_move_resources_aggregate!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.address_version_from_move_resources\""
  address_version_from_move_resources_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [address_version_from_move_resources_stream_cursor_input]! "filter the rows returned" where: address_version_from_move_resources_bool_exp): [address_version_from_move_resources!]!
  "fetch data from the table: \"block_metadata_transactions\""
  block_metadata_transactions("distinct select on columns" distinct_on: [block_metadata_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [block_metadata_transactions_order_by!] "filter the rows returned" where: block_metadata_transactions_bool_exp): [block_metadata_transactions!]!
  "fetch data from the table: \"block_metadata_transactions\" using primary key columns"
  block_metadata_transactions_by_pk(version: bigint!): block_metadata_transactions
  "fetch data from the table in a streaming manner: \"block_metadata_transactions\""
  block_metadata_transactions_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [block_metadata_transactions_stream_cursor_input]! "filter the rows returned" where: block_metadata_transactions_bool_exp): [block_metadata_transactions!]!
  "An array relationship"
  coin_activities("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "An aggregate relationship"
  coin_activities_aggregate("distinct select on columns" distinct_on: [coin_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_activities_order_by!] "filter the rows returned" where: coin_activities_bool_exp): coin_activities_aggregate!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.coin_activities\""
  coin_activities_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [coin_activities_stream_cursor_input]! "filter the rows returned" where: coin_activities_bool_exp): [coin_activities!]!
  "fetch data from the table: \"legacy_migration_v1.coin_balances\""
  coin_balances("distinct select on columns" distinct_on: [coin_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_balances_order_by!] "filter the rows returned" where: coin_balances_bool_exp): [coin_balances!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.coin_balances\""
  coin_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [coin_balances_stream_cursor_input]! "filter the rows returned" where: coin_balances_bool_exp): [coin_balances!]!
  "fetch data from the table: \"legacy_migration_v1.coin_infos\""
  coin_infos("distinct select on columns" distinct_on: [coin_infos_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_infos_order_by!] "filter the rows returned" where: coin_infos_bool_exp): [coin_infos!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.coin_infos\""
  coin_infos_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [coin_infos_stream_cursor_input]! "filter the rows returned" where: coin_infos_bool_exp): [coin_infos!]!
  "fetch data from the table: \"coin_supply\""
  coin_supply("distinct select on columns" distinct_on: [coin_supply_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [coin_supply_order_by!] "filter the rows returned" where: coin_supply_bool_exp): [coin_supply!]!
  "fetch data from the table: \"coin_supply\" using primary key columns"
  coin_supply_by_pk(coin_type_hash: String! transaction_version: bigint!): coin_supply
  "fetch data from the table in a streaming manner: \"coin_supply\""
  coin_supply_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [coin_supply_stream_cursor_input]! "filter the rows returned" where: coin_supply_bool_exp): [coin_supply!]!
  "fetch data from the table: \"legacy_migration_v1.collection_datas\""
  collection_datas("distinct select on columns" distinct_on: [collection_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [collection_datas_order_by!] "filter the rows returned" where: collection_datas_bool_exp): [collection_datas!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.collection_datas\""
  collection_datas_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [collection_datas_stream_cursor_input]! "filter the rows returned" where: collection_datas_bool_exp): [collection_datas!]!
  "fetch data from the table: \"legacy_migration_v1.current_ans_lookup\""
  current_ans_lookup("distinct select on columns" distinct_on: [current_ans_lookup_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_ans_lookup_order_by!] "filter the rows returned" where: current_ans_lookup_bool_exp): [current_ans_lookup!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.current_ans_lookup\""
  current_ans_lookup_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_ans_lookup_stream_cursor_input]! "filter the rows returned" where: current_ans_lookup_bool_exp): [current_ans_lookup!]!
  "fetch data from the table: \"current_ans_lookup_v2\""
  current_ans_lookup_v2("distinct select on columns" distinct_on: [current_ans_lookup_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_ans_lookup_v2_order_by!] "filter the rows returned" where: current_ans_lookup_v2_bool_exp): [current_ans_lookup_v2!]!
  "fetch data from the table: \"current_ans_lookup_v2\" using primary key columns"
  current_ans_lookup_v2_by_pk(domain: String! subdomain: String! token_standard: String!): current_ans_lookup_v2
  "fetch data from the table in a streaming manner: \"current_ans_lookup_v2\""
  current_ans_lookup_v2_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_ans_lookup_v2_stream_cursor_input]! "filter the rows returned" where: current_ans_lookup_v2_bool_exp): [current_ans_lookup_v2!]!
  "fetch data from the table: \"current_aptos_names\""
  current_aptos_names("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "fetch aggregated fields from the table: \"current_aptos_names\""
  current_aptos_names_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  "fetch data from the table in a streaming manner: \"current_aptos_names\""
  current_aptos_names_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_aptos_names_stream_cursor_input]! "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "fetch data from the table: \"legacy_migration_v1.current_coin_balances\""
  current_coin_balances("distinct select on columns" distinct_on: [current_coin_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_coin_balances_order_by!] "filter the rows returned" where: current_coin_balances_bool_exp): [current_coin_balances!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.current_coin_balances\""
  current_coin_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_coin_balances_stream_cursor_input]! "filter the rows returned" where: current_coin_balances_bool_exp): [current_coin_balances!]!
  "fetch data from the table: \"legacy_migration_v1.current_collection_datas\""
  current_collection_datas("distinct select on columns" distinct_on: [current_collection_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_datas_order_by!] "filter the rows returned" where: current_collection_datas_bool_exp): [current_collection_datas!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.current_collection_datas\""
  current_collection_datas_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_collection_datas_stream_cursor_input]! "filter the rows returned" where: current_collection_datas_bool_exp): [current_collection_datas!]!
  "fetch data from the table: \"current_collection_ownership_v2_view\""
  current_collection_ownership_v2_view("distinct select on columns" distinct_on: [current_collection_ownership_v2_view_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_ownership_v2_view_order_by!] "filter the rows returned" where: current_collection_ownership_v2_view_bool_exp): [current_collection_ownership_v2_view!]!
  "fetch aggregated fields from the table: \"current_collection_ownership_v2_view\""
  current_collection_ownership_v2_view_aggregate("distinct select on columns" distinct_on: [current_collection_ownership_v2_view_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collection_ownership_v2_view_order_by!] "filter the rows returned" where: current_collection_ownership_v2_view_bool_exp): current_collection_ownership_v2_view_aggregate!
  "fetch data from the table in a streaming manner: \"current_collection_ownership_v2_view\""
  current_collection_ownership_v2_view_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_collection_ownership_v2_view_stream_cursor_input]! "filter the rows returned" where: current_collection_ownership_v2_view_bool_exp): [current_collection_ownership_v2_view!]!
  "fetch data from the table: \"current_collections_v2\""
  current_collections_v2("distinct select on columns" distinct_on: [current_collections_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_collections_v2_order_by!] "filter the rows returned" where: current_collections_v2_bool_exp): [current_collections_v2!]!
  "fetch data from the table: \"current_collections_v2\" using primary key columns"
  current_collections_v2_by_pk(collection_id: String!): current_collections_v2
  "fetch data from the table in a streaming manner: \"current_collections_v2\""
  current_collections_v2_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_collections_v2_stream_cursor_input]! "filter the rows returned" where: current_collections_v2_bool_exp): [current_collections_v2!]!
  "fetch data from the table: \"current_delegated_staking_pool_balances\""
  current_delegated_staking_pool_balances("distinct select on columns" distinct_on: [current_delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegated_staking_pool_balances_order_by!] "filter the rows returned" where: current_delegated_staking_pool_balances_bool_exp): [current_delegated_staking_pool_balances!]!
  "fetch data from the table: \"current_delegated_staking_pool_balances\" using primary key columns"
  current_delegated_staking_pool_balances_by_pk(staking_pool_address: String!): current_delegated_staking_pool_balances
  "fetch data from the table in a streaming manner: \"current_delegated_staking_pool_balances\""
  current_delegated_staking_pool_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_delegated_staking_pool_balances_stream_cursor_input]! "filter the rows returned" where: current_delegated_staking_pool_balances_bool_exp): [current_delegated_staking_pool_balances!]!
  "fetch data from the table: \"current_delegated_voter\""
  current_delegated_voter("distinct select on columns" distinct_on: [current_delegated_voter_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegated_voter_order_by!] "filter the rows returned" where: current_delegated_voter_bool_exp): [current_delegated_voter!]!
  "fetch data from the table: \"current_delegated_voter\" using primary key columns"
  current_delegated_voter_by_pk(delegation_pool_address: String! delegator_address: String!): current_delegated_voter
  "fetch data from the table in a streaming manner: \"current_delegated_voter\""
  current_delegated_voter_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_delegated_voter_stream_cursor_input]! "filter the rows returned" where: current_delegated_voter_bool_exp): [current_delegated_voter!]!
  "fetch data from the table: \"current_delegator_balances\""
  current_delegator_balances("distinct select on columns" distinct_on: [current_delegator_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_delegator_balances_order_by!] "filter the rows returned" where: current_delegator_balances_bool_exp): [current_delegator_balances!]!
  "fetch data from the table: \"current_delegator_balances\" using primary key columns"
  current_delegator_balances_by_pk(delegator_address: String! pool_address: String! pool_type: String! table_handle: String!): current_delegator_balances
  "fetch data from the table in a streaming manner: \"current_delegator_balances\""
  current_delegator_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_delegator_balances_stream_cursor_input]! "filter the rows returned" where: current_delegator_balances_bool_exp): [current_delegator_balances!]!
  "fetch data from the table: \"current_fungible_asset_balances\""
  current_fungible_asset_balances("distinct select on columns" distinct_on: [current_fungible_asset_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_fungible_asset_balances_order_by!] "filter the rows returned" where: current_fungible_asset_balances_bool_exp): [current_fungible_asset_balances!]!
  "fetch aggregated fields from the table: \"current_fungible_asset_balances\""
  current_fungible_asset_balances_aggregate("distinct select on columns" distinct_on: [current_fungible_asset_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_fungible_asset_balances_order_by!] "filter the rows returned" where: current_fungible_asset_balances_bool_exp): current_fungible_asset_balances_aggregate!
  "fetch data from the table: \"current_fungible_asset_balances\" using primary key columns"
  current_fungible_asset_balances_by_pk(storage_id: String!): current_fungible_asset_balances
  "fetch data from the table in a streaming manner: \"current_fungible_asset_balances\""
  current_fungible_asset_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_fungible_asset_balances_stream_cursor_input]! "filter the rows returned" where: current_fungible_asset_balances_bool_exp): [current_fungible_asset_balances!]!
  "fetch data from the table: \"current_objects\""
  current_objects("distinct select on columns" distinct_on: [current_objects_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_objects_order_by!] "filter the rows returned" where: current_objects_bool_exp): [current_objects!]!
  "fetch data from the table: \"current_objects\" using primary key columns"
  current_objects_by_pk(object_address: String!): current_objects
  "fetch data from the table in a streaming manner: \"current_objects\""
  current_objects_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_objects_stream_cursor_input]! "filter the rows returned" where: current_objects_bool_exp): [current_objects!]!
  "fetch data from the table: \"current_staking_pool_voter\""
  current_staking_pool_voter("distinct select on columns" distinct_on: [current_staking_pool_voter_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_staking_pool_voter_order_by!] "filter the rows returned" where: current_staking_pool_voter_bool_exp): [current_staking_pool_voter!]!
  "fetch data from the table: \"current_staking_pool_voter\" using primary key columns"
  current_staking_pool_voter_by_pk(staking_pool_address: String!): current_staking_pool_voter
  "fetch data from the table in a streaming manner: \"current_staking_pool_voter\""
  current_staking_pool_voter_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_staking_pool_voter_stream_cursor_input]! "filter the rows returned" where: current_staking_pool_voter_bool_exp): [current_staking_pool_voter!]!
  "fetch data from the table: \"current_table_items\""
  current_table_items("distinct select on columns" distinct_on: [current_table_items_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_table_items_order_by!] "filter the rows returned" where: current_table_items_bool_exp): [current_table_items!]!
  "fetch data from the table: \"current_table_items\" using primary key columns"
  current_table_items_by_pk(key_hash: String! table_handle: String!): current_table_items
  "fetch data from the table in a streaming manner: \"current_table_items\""
  current_table_items_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_table_items_stream_cursor_input]! "filter the rows returned" where: current_table_items_bool_exp): [current_table_items!]!
  "fetch data from the table: \"legacy_migration_v1.current_token_datas\""
  current_token_datas("distinct select on columns" distinct_on: [current_token_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_datas_order_by!] "filter the rows returned" where: current_token_datas_bool_exp): [current_token_datas!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.current_token_datas\""
  current_token_datas_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_datas_stream_cursor_input]! "filter the rows returned" where: current_token_datas_bool_exp): [current_token_datas!]!
  "fetch data from the table: \"current_token_datas_v2\""
  current_token_datas_v2("distinct select on columns" distinct_on: [current_token_datas_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_datas_v2_order_by!] "filter the rows returned" where: current_token_datas_v2_bool_exp): [current_token_datas_v2!]!
  "fetch data from the table: \"current_token_datas_v2\" using primary key columns"
  current_token_datas_v2_by_pk(token_data_id: String!): current_token_datas_v2
  "fetch data from the table in a streaming manner: \"current_token_datas_v2\""
  current_token_datas_v2_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_datas_v2_stream_cursor_input]! "filter the rows returned" where: current_token_datas_v2_bool_exp): [current_token_datas_v2!]!
  "fetch data from the table: \"legacy_migration_v1.current_token_ownerships\""
  current_token_ownerships("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): [current_token_ownerships!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.current_token_ownerships\""
  current_token_ownerships_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_order_by!] "filter the rows returned" where: current_token_ownerships_bool_exp): current_token_ownerships_aggregate!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.current_token_ownerships\""
  current_token_ownerships_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_ownerships_stream_cursor_input]! "filter the rows returned" where: current_token_ownerships_bool_exp): [current_token_ownerships!]!
  "fetch data from the table: \"current_token_ownerships_v2\""
  current_token_ownerships_v2("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): [current_token_ownerships_v2!]!
  "fetch aggregated fields from the table: \"current_token_ownerships_v2\""
  current_token_ownerships_v2_aggregate("distinct select on columns" distinct_on: [current_token_ownerships_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_ownerships_v2_order_by!] "filter the rows returned" where: current_token_ownerships_v2_bool_exp): current_token_ownerships_v2_aggregate!
  "fetch data from the table: \"current_token_ownerships_v2\" using primary key columns"
  current_token_ownerships_v2_by_pk(owner_address: String! property_version_v1: numeric! storage_id: String! token_data_id: String!): current_token_ownerships_v2
  "fetch data from the table in a streaming manner: \"current_token_ownerships_v2\""
  current_token_ownerships_v2_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_ownerships_v2_stream_cursor_input]! "filter the rows returned" where: current_token_ownerships_v2_bool_exp): [current_token_ownerships_v2!]!
  "fetch data from the table: \"current_token_pending_claims\""
  current_token_pending_claims("distinct select on columns" distinct_on: [current_token_pending_claims_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_pending_claims_order_by!] "filter the rows returned" where: current_token_pending_claims_bool_exp): [current_token_pending_claims!]!
  "fetch data from the table: \"current_token_pending_claims\" using primary key columns"
  current_token_pending_claims_by_pk(from_address: String! property_version: numeric! to_address: String! token_data_id_hash: String!): current_token_pending_claims
  "fetch data from the table in a streaming manner: \"current_token_pending_claims\""
  current_token_pending_claims_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_pending_claims_stream_cursor_input]! "filter the rows returned" where: current_token_pending_claims_bool_exp): [current_token_pending_claims!]!
  "fetch data from the table: \"current_token_royalty_v1\""
  current_token_royalty_v1("distinct select on columns" distinct_on: [current_token_royalty_v1_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_token_royalty_v1_order_by!] "filter the rows returned" where: current_token_royalty_v1_bool_exp): [current_token_royalty_v1!]!
  "fetch data from the table: \"current_token_royalty_v1\" using primary key columns"
  current_token_royalty_v1_by_pk(token_data_id: String!): current_token_royalty_v1
  "fetch data from the table in a streaming manner: \"current_token_royalty_v1\""
  current_token_royalty_v1_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [current_token_royalty_v1_stream_cursor_input]! "filter the rows returned" where: current_token_royalty_v1_bool_exp): [current_token_royalty_v1!]!
  "An array relationship"
  delegated_staking_activities("distinct select on columns" distinct_on: [delegated_staking_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_activities_order_by!] "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "fetch data from the table: \"delegated_staking_activities\" using primary key columns"
  delegated_staking_activities_by_pk(event_index: bigint! transaction_version: bigint!): delegated_staking_activities
  "fetch data from the table in a streaming manner: \"delegated_staking_activities\""
  delegated_staking_activities_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [delegated_staking_activities_stream_cursor_input]! "filter the rows returned" where: delegated_staking_activities_bool_exp): [delegated_staking_activities!]!
  "fetch data from the table: \"delegated_staking_pool_balances\""
  delegated_staking_pool_balances("distinct select on columns" distinct_on: [delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pool_balances_order_by!] "filter the rows returned" where: delegated_staking_pool_balances_bool_exp): [delegated_staking_pool_balances!]!
  "fetch aggregated fields from the table: \"delegated_staking_pool_balances\""
  delegated_staking_pool_balances_aggregate("distinct select on columns" distinct_on: [delegated_staking_pool_balances_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pool_balances_order_by!] "filter the rows returned" where: delegated_staking_pool_balances_bool_exp): delegated_staking_pool_balances_aggregate!
  "fetch data from the table: \"delegated_staking_pool_balances\" using primary key columns"
  delegated_staking_pool_balances_by_pk(staking_pool_address: String! transaction_version: bigint!): delegated_staking_pool_balances
  "fetch data from the table in a streaming manner: \"delegated_staking_pool_balances\""
  delegated_staking_pool_balances_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [delegated_staking_pool_balances_stream_cursor_input]! "filter the rows returned" where: delegated_staking_pool_balances_bool_exp): [delegated_staking_pool_balances!]!
  "fetch data from the table: \"delegated_staking_pools\""
  delegated_staking_pools("distinct select on columns" distinct_on: [delegated_staking_pools_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegated_staking_pools_order_by!] "filter the rows returned" where: delegated_staking_pools_bool_exp): [delegated_staking_pools!]!
  "fetch data from the table: \"delegated_staking_pools\" using primary key columns"
  delegated_staking_pools_by_pk(staking_pool_address: String!): delegated_staking_pools
  "fetch data from the table in a streaming manner: \"delegated_staking_pools\""
  delegated_staking_pools_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [delegated_staking_pools_stream_cursor_input]! "filter the rows returned" where: delegated_staking_pools_bool_exp): [delegated_staking_pools!]!
  "fetch data from the table: \"delegator_distinct_pool\""
  delegator_distinct_pool("distinct select on columns" distinct_on: [delegator_distinct_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegator_distinct_pool_order_by!] "filter the rows returned" where: delegator_distinct_pool_bool_exp): [delegator_distinct_pool!]!
  "fetch aggregated fields from the table: \"delegator_distinct_pool\""
  delegator_distinct_pool_aggregate("distinct select on columns" distinct_on: [delegator_distinct_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [delegator_distinct_pool_order_by!] "filter the rows returned" where: delegator_distinct_pool_bool_exp): delegator_distinct_pool_aggregate!
  "fetch data from the table in a streaming manner: \"delegator_distinct_pool\""
  delegator_distinct_pool_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [delegator_distinct_pool_stream_cursor_input]! "filter the rows returned" where: delegator_distinct_pool_bool_exp): [delegator_distinct_pool!]!
  "fetch data from the table: \"events\""
  events("distinct select on columns" distinct_on: [events_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [events_order_by!] "filter the rows returned" where: events_bool_exp): [events!]!
  "fetch data from the table: \"events\" using primary key columns"
  events_by_pk(event_index: bigint! transaction_version: bigint!): events
  "fetch data from the table in a streaming manner: \"events\""
  events_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [events_stream_cursor_input]! "filter the rows returned" where: events_bool_exp): [events!]!
  "An array relationship"
  fungible_asset_activities("distinct select on columns" distinct_on: [fungible_asset_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fungible_asset_activities_order_by!] "filter the rows returned" where: fungible_asset_activities_bool_exp): [fungible_asset_activities!]!
  "fetch data from the table: \"fungible_asset_activities\" using primary key columns"
  fungible_asset_activities_by_pk(event_index: bigint! transaction_version: bigint!): fungible_asset_activities
  "fetch data from the table in a streaming manner: \"fungible_asset_activities\""
  fungible_asset_activities_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [fungible_asset_activities_stream_cursor_input]! "filter the rows returned" where: fungible_asset_activities_bool_exp): [fungible_asset_activities!]!
  "fetch data from the table: \"fungible_asset_metadata\""
  fungible_asset_metadata("distinct select on columns" distinct_on: [fungible_asset_metadata_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [fungible_asset_metadata_order_by!] "filter the rows returned" where: fungible_asset_metadata_bool_exp): [fungible_asset_metadata!]!
  "fetch data from the table: \"fungible_asset_metadata\" using primary key columns"
  fungible_asset_metadata_by_pk(asset_type: String!): fungible_asset_metadata
  "fetch data from the table in a streaming manner: \"fungible_asset_metadata\""
  fungible_asset_metadata_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [fungible_asset_metadata_stream_cursor_input]! "filter the rows returned" where: fungible_asset_metadata_bool_exp): [fungible_asset_metadata!]!
  "fetch data from the table: \"indexer_status\""
  indexer_status("distinct select on columns" distinct_on: [indexer_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [indexer_status_order_by!] "filter the rows returned" where: indexer_status_bool_exp): [indexer_status!]!
  "fetch data from the table: \"indexer_status\" using primary key columns"
  indexer_status_by_pk(db: String!): indexer_status
  "fetch data from the table in a streaming manner: \"indexer_status\""
  indexer_status_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [indexer_status_stream_cursor_input]! "filter the rows returned" where: indexer_status_bool_exp): [indexer_status!]!
  "fetch data from the table: \"ledger_infos\""
  ledger_infos("distinct select on columns" distinct_on: [ledger_infos_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [ledger_infos_order_by!] "filter the rows returned" where: ledger_infos_bool_exp): [ledger_infos!]!
  "fetch data from the table: \"ledger_infos\" using primary key columns"
  ledger_infos_by_pk(chain_id: bigint!): ledger_infos
  "fetch data from the table in a streaming manner: \"ledger_infos\""
  ledger_infos_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [ledger_infos_stream_cursor_input]! "filter the rows returned" where: ledger_infos_bool_exp): [ledger_infos!]!
  "fetch data from the table: \"legacy_migration_v1.move_resources\""
  move_resources("distinct select on columns" distinct_on: [move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [move_resources_order_by!] "filter the rows returned" where: move_resources_bool_exp): [move_resources!]!
  "fetch aggregated fields from the table: \"legacy_migration_v1.move_resources\""
  move_resources_aggregate("distinct select on columns" distinct_on: [move_resources_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [move_resources_order_by!] "filter the rows returned" where: move_resources_bool_exp): move_resources_aggregate!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.move_resources\""
  move_resources_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [move_resources_stream_cursor_input]! "filter the rows returned" where: move_resources_bool_exp): [move_resources!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\""
  nft_marketplace_v2_current_nft_marketplace_auctions("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_auctions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_auctions_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp): [nft_marketplace_v2_current_nft_marketplace_auctions!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_auctions\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_auctions_by_pk(listing_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_auctions
  "fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_auctions\""
  nft_marketplace_v2_current_nft_marketplace_auctions_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_marketplace_v2_current_nft_marketplace_auctions_stream_cursor_input]! "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_auctions_bool_exp): [nft_marketplace_v2_current_nft_marketplace_auctions!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\""
  nft_marketplace_v2_current_nft_marketplace_collection_offers("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_collection_offers_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_collection_offers_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_collection_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_collection_offers_by_pk(collection_id: String! collection_offer_id: String!): nft_marketplace_v2_current_nft_marketplace_collection_offers
  "fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_collection_offers\""
  nft_marketplace_v2_current_nft_marketplace_collection_offers_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_marketplace_v2_current_nft_marketplace_collection_offers_stream_cursor_input]! "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_collection_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_collection_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\""
  nft_marketplace_v2_current_nft_marketplace_listings("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_listings_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_listings_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp): [nft_marketplace_v2_current_nft_marketplace_listings!]!
  "fetch aggregated fields from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\""
  nft_marketplace_v2_current_nft_marketplace_listings_aggregate("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_listings_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_listings_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp): nft_marketplace_v2_current_nft_marketplace_listings_aggregate!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_listings\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_listings_by_pk(listing_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_listings
  "fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_listings\""
  nft_marketplace_v2_current_nft_marketplace_listings_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_marketplace_v2_current_nft_marketplace_listings_stream_cursor_input]! "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_listings_bool_exp): [nft_marketplace_v2_current_nft_marketplace_listings!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\""
  nft_marketplace_v2_current_nft_marketplace_token_offers("distinct select on columns" distinct_on: [nft_marketplace_v2_current_nft_marketplace_token_offers_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_current_nft_marketplace_token_offers_order_by!] "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_token_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.current_nft_marketplace_token_offers\" using primary key columns"
  nft_marketplace_v2_current_nft_marketplace_token_offers_by_pk(offer_id: String! token_data_id: String!): nft_marketplace_v2_current_nft_marketplace_token_offers
  "fetch data from the table in a streaming manner: \"nft_marketplace_v2.current_nft_marketplace_token_offers\""
  nft_marketplace_v2_current_nft_marketplace_token_offers_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_marketplace_v2_current_nft_marketplace_token_offers_stream_cursor_input]! "filter the rows returned" where: nft_marketplace_v2_current_nft_marketplace_token_offers_bool_exp): [nft_marketplace_v2_current_nft_marketplace_token_offers!]!
  "fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\""
  nft_marketplace_v2_nft_marketplace_activities("distinct select on columns" distinct_on: [nft_marketplace_v2_nft_marketplace_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_marketplace_v2_nft_marketplace_activities_order_by!] "filter the rows returned" where: nft_marketplace_v2_nft_marketplace_activities_bool_exp): [nft_marketplace_v2_nft_marketplace_activities!]!
  "fetch data from the table: \"nft_marketplace_v2.nft_marketplace_activities\" using primary key columns"
  nft_marketplace_v2_nft_marketplace_activities_by_pk(event_index: bigint! transaction_version: bigint!): nft_marketplace_v2_nft_marketplace_activities
  "fetch data from the table in a streaming manner: \"nft_marketplace_v2.nft_marketplace_activities\""
  nft_marketplace_v2_nft_marketplace_activities_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_marketplace_v2_nft_marketplace_activities_stream_cursor_input]! "filter the rows returned" where: nft_marketplace_v2_nft_marketplace_activities_bool_exp): [nft_marketplace_v2_nft_marketplace_activities!]!
  "fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\""
  nft_metadata_crawler_parsed_asset_uris("distinct select on columns" distinct_on: [nft_metadata_crawler_parsed_asset_uris_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [nft_metadata_crawler_parsed_asset_uris_order_by!] "filter the rows returned" where: nft_metadata_crawler_parsed_asset_uris_bool_exp): [nft_metadata_crawler_parsed_asset_uris!]!
  "fetch data from the table: \"nft_metadata_crawler.parsed_asset_uris\" using primary key columns"
  nft_metadata_crawler_parsed_asset_uris_by_pk(asset_uri: String!): nft_metadata_crawler_parsed_asset_uris
  "fetch data from the table in a streaming manner: \"nft_metadata_crawler.parsed_asset_uris\""
  nft_metadata_crawler_parsed_asset_uris_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [nft_metadata_crawler_parsed_asset_uris_stream_cursor_input]! "filter the rows returned" where: nft_metadata_crawler_parsed_asset_uris_bool_exp): [nft_metadata_crawler_parsed_asset_uris!]!
  "fetch data from the table: \"num_active_delegator_per_pool\""
  num_active_delegator_per_pool("distinct select on columns" distinct_on: [num_active_delegator_per_pool_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [num_active_delegator_per_pool_order_by!] "filter the rows returned" where: num_active_delegator_per_pool_bool_exp): [num_active_delegator_per_pool!]!
  "fetch data from the table in a streaming manner: \"num_active_delegator_per_pool\""
  num_active_delegator_per_pool_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [num_active_delegator_per_pool_stream_cursor_input]! "filter the rows returned" where: num_active_delegator_per_pool_bool_exp): [num_active_delegator_per_pool!]!
  "fetch data from the table: \"processor_status\""
  processor_status("distinct select on columns" distinct_on: [processor_status_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [processor_status_order_by!] "filter the rows returned" where: processor_status_bool_exp): [processor_status!]!
  "fetch data from the table: \"processor_status\" using primary key columns"
  processor_status_by_pk(processor: String!): processor_status
  "fetch data from the table in a streaming manner: \"processor_status\""
  processor_status_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [processor_status_stream_cursor_input]! "filter the rows returned" where: processor_status_bool_exp): [processor_status!]!
  "fetch data from the table: \"proposal_votes\""
  proposal_votes("distinct select on columns" distinct_on: [proposal_votes_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_votes_order_by!] "filter the rows returned" where: proposal_votes_bool_exp): [proposal_votes!]!
  "fetch aggregated fields from the table: \"proposal_votes\""
  proposal_votes_aggregate("distinct select on columns" distinct_on: [proposal_votes_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [proposal_votes_order_by!] "filter the rows returned" where: proposal_votes_bool_exp): proposal_votes_aggregate!
  "fetch data from the table: \"proposal_votes\" using primary key columns"
  proposal_votes_by_pk(proposal_id: bigint! transaction_version: bigint! voter_address: String!): proposal_votes
  "fetch data from the table in a streaming manner: \"proposal_votes\""
  proposal_votes_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [proposal_votes_stream_cursor_input]! "filter the rows returned" where: proposal_votes_bool_exp): [proposal_votes!]!
  "fetch data from the table: \"signatures\""
  signatures("distinct select on columns" distinct_on: [signatures_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [signatures_order_by!] "filter the rows returned" where: signatures_bool_exp): [signatures!]!
  "fetch data from the table: \"signatures\" using primary key columns"
  signatures_by_pk(is_sender_primary: Boolean! multi_agent_index: bigint! multi_sig_index: bigint! transaction_version: bigint!): signatures
  "fetch data from the table in a streaming manner: \"signatures\""
  signatures_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [signatures_stream_cursor_input]! "filter the rows returned" where: signatures_bool_exp): [signatures!]!
  "fetch data from the table: \"table_items\""
  table_items("distinct select on columns" distinct_on: [table_items_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [table_items_order_by!] "filter the rows returned" where: table_items_bool_exp): [table_items!]!
  "fetch data from the table: \"table_items\" using primary key columns"
  table_items_by_pk(transaction_version: bigint! write_set_change_index: bigint!): table_items
  "fetch data from the table in a streaming manner: \"table_items\""
  table_items_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [table_items_stream_cursor_input]! "filter the rows returned" where: table_items_bool_exp): [table_items!]!
  "fetch data from the table: \"table_metadatas\""
  table_metadatas("distinct select on columns" distinct_on: [table_metadatas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [table_metadatas_order_by!] "filter the rows returned" where: table_metadatas_bool_exp): [table_metadatas!]!
  "fetch data from the table: \"table_metadatas\" using primary key columns"
  table_metadatas_by_pk(handle: String!): table_metadatas
  "fetch data from the table in a streaming manner: \"table_metadatas\""
  table_metadatas_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [table_metadatas_stream_cursor_input]! "filter the rows returned" where: table_metadatas_bool_exp): [table_metadatas!]!
  "An array relationship"
  token_activities("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An aggregate relationship"
  token_activities_aggregate("distinct select on columns" distinct_on: [token_activities_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_order_by!] "filter the rows returned" where: token_activities_bool_exp): token_activities_aggregate!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.token_activities\""
  token_activities_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [token_activities_stream_cursor_input]! "filter the rows returned" where: token_activities_bool_exp): [token_activities!]!
  "An array relationship"
  token_activities_v2("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "An aggregate relationship"
  token_activities_v2_aggregate("distinct select on columns" distinct_on: [token_activities_v2_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_activities_v2_order_by!] "filter the rows returned" where: token_activities_v2_bool_exp): token_activities_v2_aggregate!
  "fetch data from the table: \"token_activities_v2\" using primary key columns"
  token_activities_v2_by_pk(event_index: bigint! transaction_version: bigint!): token_activities_v2
  "fetch data from the table in a streaming manner: \"token_activities_v2\""
  token_activities_v2_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [token_activities_v2_stream_cursor_input]! "filter the rows returned" where: token_activities_v2_bool_exp): [token_activities_v2!]!
  "fetch data from the table: \"legacy_migration_v1.token_datas\""
  token_datas("distinct select on columns" distinct_on: [token_datas_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_datas_order_by!] "filter the rows returned" where: token_datas_bool_exp): [token_datas!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.token_datas\""
  token_datas_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [token_datas_stream_cursor_input]! "filter the rows returned" where: token_datas_bool_exp): [token_datas!]!
  "fetch data from the table: \"legacy_migration_v1.token_ownerships\""
  token_ownerships("distinct select on columns" distinct_on: [token_ownerships_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [token_ownerships_order_by!] "filter the rows returned" where: token_ownerships_bool_exp): [token_ownerships!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.token_ownerships\""
  token_ownerships_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [token_ownerships_stream_cursor_input]! "filter the rows returned" where: token_ownerships_bool_exp): [token_ownerships!]!
  "fetch data from the table: \"legacy_migration_v1.tokens\""
  tokens("distinct select on columns" distinct_on: [tokens_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [tokens_order_by!] "filter the rows returned" where: tokens_bool_exp): [tokens!]!
  "fetch data from the table in a streaming manner: \"legacy_migration_v1.tokens\""
  tokens_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [tokens_stream_cursor_input]! "filter the rows returned" where: tokens_bool_exp): [tokens!]!
  "fetch data from the table: \"user_transactions\""
  user_transactions("distinct select on columns" distinct_on: [user_transactions_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [user_transactions_order_by!] "filter the rows returned" where: user_transactions_bool_exp): [user_transactions!]!
  "fetch data from the table: \"user_transactions\" using primary key columns"
  user_transactions_by_pk(version: bigint!): user_transactions
  "fetch data from the table in a streaming manner: \"user_transactions\""
  user_transactions_stream("maximum number of rows returned in a single batch" batch_size: Int! "cursor to stream the results returned by the query" cursor: [user_transactions_stream_cursor_input]! "filter the rows returned" where: user_transactions_bool_exp): [user_transactions!]!
}

"columns and relationships of \"table_items\""
type table_items {
  decoded_key("JSON select path" path: String): jsonb
  decoded_value("JSON select path" path: String): jsonb
  key: String!
  table_handle: String!
  transaction_version: bigint!
  write_set_change_index: bigint!
}

"Boolean expression to filter rows from the table \"table_items\". All fields are combined with a logical 'AND'."
input table_items_bool_exp {
  _and: [table_items_bool_exp!]
  _not: table_items_bool_exp
  _or: [table_items_bool_exp!]
  decoded_key: jsonb_comparison_exp
  decoded_value: jsonb_comparison_exp
  key: String_comparison_exp
  table_handle: String_comparison_exp
  transaction_version: bigint_comparison_exp
  write_set_change_index: bigint_comparison_exp
}

"Ordering options when selecting data from \"table_items\"."
input table_items_order_by {
  decoded_key: order_by
  decoded_value: order_by
  key: order_by
  table_handle: order_by
  transaction_version: order_by
  write_set_change_index: order_by
}

"select columns of table \"table_items\""
enum table_items_select_column {
  "column name"
  decoded_key
  "column name"
  decoded_value
  "column name"
  key
  "column name"
  table_handle
  "column name"
  transaction_version
  "column name"
  write_set_change_index
}

"Streaming cursor of the table \"table_items\""
input table_items_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: table_items_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input table_items_stream_cursor_value_input {
  decoded_key: jsonb
  decoded_value: jsonb
  key: String
  table_handle: String
  transaction_version: bigint
  write_set_change_index: bigint
}

"columns and relationships of \"table_metadatas\""
type table_metadatas {
  handle: String!
  key_type: String!
  value_type: String!
}

"Boolean expression to filter rows from the table \"table_metadatas\". All fields are combined with a logical 'AND'."
input table_metadatas_bool_exp {
  _and: [table_metadatas_bool_exp!]
  _not: table_metadatas_bool_exp
  _or: [table_metadatas_bool_exp!]
  handle: String_comparison_exp
  key_type: String_comparison_exp
  value_type: String_comparison_exp
}

"Ordering options when selecting data from \"table_metadatas\"."
input table_metadatas_order_by {
  handle: order_by
  key_type: order_by
  value_type: order_by
}

"select columns of table \"table_metadatas\""
enum table_metadatas_select_column {
  "column name"
  handle
  "column name"
  key_type
  "column name"
  value_type
}

"Streaming cursor of the table \"table_metadatas\""
input table_metadatas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: table_metadatas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input table_metadatas_stream_cursor_value_input {
  handle: String
  key_type: String
  value_type: String
}

scalar timestamp

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"Boolean expression to compare columns of type \"timestamptz\". All fields are combined with logical 'AND'."
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"columns and relationships of \"legacy_migration_v1.token_activities\""
type token_activities {
  "An array relationship"
  aptos_names_owner("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  aptos_names_owner_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  "An array relationship"
  aptos_names_to("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  aptos_names_to_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  "An object relationship"
  current_token_data: current_token_datas
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"aggregated selection of \"legacy_migration_v1.token_activities\""
type token_activities_aggregate {
  aggregate: token_activities_aggregate_fields
  nodes: [token_activities!]!
}

input token_activities_aggregate_bool_exp {
  count: token_activities_aggregate_bool_exp_count
}

input token_activities_aggregate_bool_exp_count {
  arguments: [token_activities_select_column!]
  distinct: Boolean
  filter: token_activities_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"legacy_migration_v1.token_activities\""
type token_activities_aggregate_fields {
  avg: token_activities_avg_fields
  count(columns: [token_activities_select_column!] distinct: Boolean): Int!
  max: token_activities_max_fields
  min: token_activities_min_fields
  stddev: token_activities_stddev_fields
  stddev_pop: token_activities_stddev_pop_fields
  stddev_samp: token_activities_stddev_samp_fields
  sum: token_activities_sum_fields
  var_pop: token_activities_var_pop_fields
  var_samp: token_activities_var_samp_fields
  variance: token_activities_variance_fields
}

"order by aggregate values of table \"legacy_migration_v1.token_activities\""
input token_activities_aggregate_order_by {
  avg: token_activities_avg_order_by
  count: order_by
  max: token_activities_max_order_by
  min: token_activities_min_order_by
  stddev: token_activities_stddev_order_by
  stddev_pop: token_activities_stddev_pop_order_by
  stddev_samp: token_activities_stddev_samp_order_by
  sum: token_activities_sum_order_by
  var_pop: token_activities_var_pop_order_by
  var_samp: token_activities_var_samp_order_by
  variance: token_activities_variance_order_by
}

"aggregate avg on columns"
type token_activities_avg_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by avg() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_avg_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.token_activities\". All fields are combined with a logical 'AND'."
input token_activities_bool_exp {
  _and: [token_activities_bool_exp!]
  _not: token_activities_bool_exp
  _or: [token_activities_bool_exp!]
  aptos_names_owner: current_aptos_names_bool_exp
  aptos_names_owner_aggregate: current_aptos_names_aggregate_bool_exp
  aptos_names_to: current_aptos_names_bool_exp
  aptos_names_to_aggregate: current_aptos_names_aggregate_bool_exp
  coin_amount: String_comparison_exp
  coin_type: String_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  current_token_data: current_token_datas_bool_exp
  event_account_address: String_comparison_exp
  event_creation_number: Int_comparison_exp
  event_index: bigint_comparison_exp
  event_sequence_number: Int_comparison_exp
  from_address: String_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  to_address: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  transfer_type: String_comparison_exp
}

"aggregate max on columns"
type token_activities_max_fields {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"order by max() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_max_order_by {
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"aggregate min on columns"
type token_activities_min_fields {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"order by min() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_min_order_by {
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"Ordering options when selecting data from \"legacy_migration_v1.token_activities\"."
input token_activities_order_by {
  aptos_names_owner_aggregate: current_aptos_names_aggregate_order_by
  aptos_names_to_aggregate: current_aptos_names_aggregate_order_by
  coin_amount: order_by
  coin_type: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  current_token_data: current_token_datas_order_by
  event_account_address: order_by
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  from_address: order_by
  name: order_by
  property_version: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  transfer_type: order_by
}

"select columns of table \"legacy_migration_v1.token_activities\""
enum token_activities_select_column {
  "column name"
  coin_amount
  "column name"
  coin_type
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  event_account_address
  "column name"
  event_creation_number
  "column name"
  event_index
  "column name"
  event_sequence_number
  "column name"
  from_address
  "column name"
  name
  "column name"
  property_version
  "column name"
  to_address
  "column name"
  token_amount
  "column name"
  token_data_id_hash
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  transfer_type
}

"aggregate stddev on columns"
type token_activities_stddev_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_stddev_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_pop on columns"
type token_activities_stddev_pop_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev_pop() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_stddev_pop_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_samp on columns"
type token_activities_stddev_samp_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev_samp() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_stddev_samp_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"Streaming cursor of the table \"token_activities\""
input token_activities_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: token_activities_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input token_activities_stream_cursor_value_input {
  coin_amount: String
  coin_type: String
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  event_account_address: String
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  from_address: String
  name: String
  property_version: numeric
  to_address: String
  token_amount: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  transfer_type: String
}

"aggregate sum on columns"
type token_activities_sum_fields {
  event_creation_number: Int
  event_index: bigint
  event_sequence_number: Int
  property_version: numeric
  token_amount: numeric
  transaction_version: bigint
}

"order by sum() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_sum_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"columns and relationships of \"token_activities_v2\""
type token_activities_v2 {
  after_value: String
  "An array relationship"
  aptos_names_from("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  aptos_names_from_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  "An array relationship"
  aptos_names_to("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): [current_aptos_names!]!
  "An aggregate relationship"
  aptos_names_to_aggregate("distinct select on columns" distinct_on: [current_aptos_names_select_column!] "limit the number of rows returned" limit: Int "skip the first n rows. Use only with order_by" offset: Int "sort the rows by one or more columns" order_by: [current_aptos_names_order_by!] "filter the rows returned" where: current_aptos_names_bool_exp): current_aptos_names_aggregate!
  before_value: String
  "An object relationship"
  current_token_data: current_token_datas_v2
  entry_function_id_str: String
  event_account_address: String!
  event_index: bigint!
  from_address: String
  is_fungible_v2: Boolean
  property_version_v1: numeric!
  to_address: String
  token_amount: numeric!
  token_data_id: String!
  token_standard: String!
  transaction_timestamp: timestamp!
  transaction_version: bigint!
  type: String!
}

"aggregated selection of \"token_activities_v2\""
type token_activities_v2_aggregate {
  aggregate: token_activities_v2_aggregate_fields
  nodes: [token_activities_v2!]!
}

input token_activities_v2_aggregate_bool_exp {
  bool_and: token_activities_v2_aggregate_bool_exp_bool_and
  bool_or: token_activities_v2_aggregate_bool_exp_bool_or
  count: token_activities_v2_aggregate_bool_exp_count
}

input token_activities_v2_aggregate_bool_exp_bool_and {
  arguments: token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns!
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input token_activities_v2_aggregate_bool_exp_bool_or {
  arguments: token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns!
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Boolean_comparison_exp!
}

input token_activities_v2_aggregate_bool_exp_count {
  arguments: [token_activities_v2_select_column!]
  distinct: Boolean
  filter: token_activities_v2_bool_exp
  predicate: Int_comparison_exp!
}

"aggregate fields of \"token_activities_v2\""
type token_activities_v2_aggregate_fields {
  avg: token_activities_v2_avg_fields
  count(columns: [token_activities_v2_select_column!] distinct: Boolean): Int!
  max: token_activities_v2_max_fields
  min: token_activities_v2_min_fields
  stddev: token_activities_v2_stddev_fields
  stddev_pop: token_activities_v2_stddev_pop_fields
  stddev_samp: token_activities_v2_stddev_samp_fields
  sum: token_activities_v2_sum_fields
  var_pop: token_activities_v2_var_pop_fields
  var_samp: token_activities_v2_var_samp_fields
  variance: token_activities_v2_variance_fields
}

"order by aggregate values of table \"token_activities_v2\""
input token_activities_v2_aggregate_order_by {
  avg: token_activities_v2_avg_order_by
  count: order_by
  max: token_activities_v2_max_order_by
  min: token_activities_v2_min_order_by
  stddev: token_activities_v2_stddev_order_by
  stddev_pop: token_activities_v2_stddev_pop_order_by
  stddev_samp: token_activities_v2_stddev_samp_order_by
  sum: token_activities_v2_sum_order_by
  var_pop: token_activities_v2_var_pop_order_by
  var_samp: token_activities_v2_var_samp_order_by
  variance: token_activities_v2_variance_order_by
}

"aggregate avg on columns"
type token_activities_v2_avg_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by avg() on columns of table \"token_activities_v2\""
input token_activities_v2_avg_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"Boolean expression to filter rows from the table \"token_activities_v2\". All fields are combined with a logical 'AND'."
input token_activities_v2_bool_exp {
  _and: [token_activities_v2_bool_exp!]
  _not: token_activities_v2_bool_exp
  _or: [token_activities_v2_bool_exp!]
  after_value: String_comparison_exp
  aptos_names_from: current_aptos_names_bool_exp
  aptos_names_from_aggregate: current_aptos_names_aggregate_bool_exp
  aptos_names_to: current_aptos_names_bool_exp
  aptos_names_to_aggregate: current_aptos_names_aggregate_bool_exp
  before_value: String_comparison_exp
  current_token_data: current_token_datas_v2_bool_exp
  entry_function_id_str: String_comparison_exp
  event_account_address: String_comparison_exp
  event_index: bigint_comparison_exp
  from_address: String_comparison_exp
  is_fungible_v2: Boolean_comparison_exp
  property_version_v1: numeric_comparison_exp
  to_address: String_comparison_exp
  token_amount: numeric_comparison_exp
  token_data_id: String_comparison_exp
  token_standard: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  type: String_comparison_exp
}

"aggregate max on columns"
type token_activities_v2_max_fields {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"order by max() on columns of table \"token_activities_v2\""
input token_activities_v2_max_order_by {
  after_value: order_by
  before_value: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"aggregate min on columns"
type token_activities_v2_min_fields {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"order by min() on columns of table \"token_activities_v2\""
input token_activities_v2_min_order_by {
  after_value: order_by
  before_value: order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"Ordering options when selecting data from \"token_activities_v2\"."
input token_activities_v2_order_by {
  after_value: order_by
  aptos_names_from_aggregate: current_aptos_names_aggregate_order_by
  aptos_names_to_aggregate: current_aptos_names_aggregate_order_by
  before_value: order_by
  current_token_data: current_token_datas_v2_order_by
  entry_function_id_str: order_by
  event_account_address: order_by
  event_index: order_by
  from_address: order_by
  is_fungible_v2: order_by
  property_version_v1: order_by
  to_address: order_by
  token_amount: order_by
  token_data_id: order_by
  token_standard: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  type: order_by
}

"select columns of table \"token_activities_v2\""
enum token_activities_v2_select_column {
  "column name"
  after_value
  "column name"
  before_value
  "column name"
  entry_function_id_str
  "column name"
  event_account_address
  "column name"
  event_index
  "column name"
  from_address
  "column name"
  is_fungible_v2
  "column name"
  property_version_v1
  "column name"
  to_address
  "column name"
  token_amount
  "column name"
  token_data_id
  "column name"
  token_standard
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  type
}

"select \"token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns\" columns of table \"token_activities_v2\""
enum token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_and_arguments_columns {
  "column name"
  is_fungible_v2
}

"select \"token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns\" columns of table \"token_activities_v2\""
enum token_activities_v2_select_column_token_activities_v2_aggregate_bool_exp_bool_or_arguments_columns {
  "column name"
  is_fungible_v2
}

"aggregate stddev on columns"
type token_activities_v2_stddev_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev() on columns of table \"token_activities_v2\""
input token_activities_v2_stddev_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_pop on columns"
type token_activities_v2_stddev_pop_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev_pop() on columns of table \"token_activities_v2\""
input token_activities_v2_stddev_pop_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate stddev_samp on columns"
type token_activities_v2_stddev_samp_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by stddev_samp() on columns of table \"token_activities_v2\""
input token_activities_v2_stddev_samp_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"Streaming cursor of the table \"token_activities_v2\""
input token_activities_v2_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: token_activities_v2_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input token_activities_v2_stream_cursor_value_input {
  after_value: String
  before_value: String
  entry_function_id_str: String
  event_account_address: String
  event_index: bigint
  from_address: String
  is_fungible_v2: Boolean
  property_version_v1: numeric
  to_address: String
  token_amount: numeric
  token_data_id: String
  token_standard: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  type: String
}

"aggregate sum on columns"
type token_activities_v2_sum_fields {
  event_index: bigint
  property_version_v1: numeric
  token_amount: numeric
  transaction_version: bigint
}

"order by sum() on columns of table \"token_activities_v2\""
input token_activities_v2_sum_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate var_pop on columns"
type token_activities_v2_var_pop_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by var_pop() on columns of table \"token_activities_v2\""
input token_activities_v2_var_pop_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate var_samp on columns"
type token_activities_v2_var_samp_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by var_samp() on columns of table \"token_activities_v2\""
input token_activities_v2_var_samp_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate variance on columns"
type token_activities_v2_variance_fields {
  event_index: Float
  property_version_v1: Float
  token_amount: Float
  transaction_version: Float
}

"order by variance() on columns of table \"token_activities_v2\""
input token_activities_v2_variance_order_by {
  event_index: order_by
  property_version_v1: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate var_pop on columns"
type token_activities_var_pop_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by var_pop() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_var_pop_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate var_samp on columns"
type token_activities_var_samp_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by var_samp() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_var_samp_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"aggregate variance on columns"
type token_activities_variance_fields {
  event_creation_number: Float
  event_index: Float
  event_sequence_number: Float
  property_version: Float
  token_amount: Float
  transaction_version: Float
}

"order by variance() on columns of table \"legacy_migration_v1.token_activities\""
input token_activities_variance_order_by {
  event_creation_number: order_by
  event_index: order_by
  event_sequence_number: order_by
  property_version: order_by
  token_amount: order_by
  transaction_version: order_by
}

"columns and relationships of \"legacy_migration_v1.token_datas\""
type token_datas {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties("JSON select path" path: String): jsonb
  description: String
  description_mutable: Boolean
  largest_property_version: numeric
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.token_datas\". All fields are combined with a logical 'AND'."
input token_datas_bool_exp {
  _and: [token_datas_bool_exp!]
  _not: token_datas_bool_exp
  _or: [token_datas_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  default_properties: jsonb_comparison_exp
  description: String_comparison_exp
  description_mutable: Boolean_comparison_exp
  largest_property_version: numeric_comparison_exp
  maximum: numeric_comparison_exp
  maximum_mutable: Boolean_comparison_exp
  metadata_uri: String_comparison_exp
  name: String_comparison_exp
  payee_address: String_comparison_exp
  properties_mutable: Boolean_comparison_exp
  royalty_mutable: Boolean_comparison_exp
  royalty_points_denominator: String_comparison_exp
  royalty_points_numerator: String_comparison_exp
  supply: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
  uri_mutable: Boolean_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.token_datas\"."
input token_datas_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  default_properties: order_by
  description: order_by
  description_mutable: order_by
  largest_property_version: order_by
  maximum: order_by
  maximum_mutable: order_by
  metadata_uri: order_by
  name: order_by
  payee_address: order_by
  properties_mutable: order_by
  royalty_mutable: order_by
  royalty_points_denominator: order_by
  royalty_points_numerator: order_by
  supply: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
  uri_mutable: order_by
}

"select columns of table \"legacy_migration_v1.token_datas\""
enum token_datas_select_column {
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  default_properties
  "column name"
  description
  "column name"
  description_mutable
  "column name"
  largest_property_version
  "column name"
  maximum
  "column name"
  maximum_mutable
  "column name"
  metadata_uri
  "column name"
  name
  "column name"
  payee_address
  "column name"
  properties_mutable
  "column name"
  royalty_mutable
  "column name"
  royalty_points_denominator
  "column name"
  royalty_points_numerator
  "column name"
  supply
  "column name"
  token_data_id_hash
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
  "column name"
  uri_mutable
}

"Streaming cursor of the table \"token_datas\""
input token_datas_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: token_datas_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input token_datas_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  default_properties: jsonb
  description: String
  description_mutable: Boolean
  largest_property_version: numeric
  maximum: numeric
  maximum_mutable: Boolean
  metadata_uri: String
  name: String
  payee_address: String
  properties_mutable: Boolean
  royalty_mutable: Boolean
  royalty_points_denominator: String
  royalty_points_numerator: String
  supply: numeric
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
  uri_mutable: Boolean
}

"columns and relationships of \"legacy_migration_v1.token_ownerships\""
type token_ownerships {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.token_ownerships\". All fields are combined with a logical 'AND'."
input token_ownerships_bool_exp {
  _and: [token_ownerships_bool_exp!]
  _not: token_ownerships_bool_exp
  _or: [token_ownerships_bool_exp!]
  amount: numeric_comparison_exp
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  name: String_comparison_exp
  owner_address: String_comparison_exp
  property_version: numeric_comparison_exp
  table_handle: String_comparison_exp
  table_type: String_comparison_exp
  token_data_id_hash: String_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.token_ownerships\"."
input token_ownerships_order_by {
  amount: order_by
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  name: order_by
  owner_address: order_by
  property_version: order_by
  table_handle: order_by
  table_type: order_by
  token_data_id_hash: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.token_ownerships\""
enum token_ownerships_select_column {
  "column name"
  amount
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  name
  "column name"
  owner_address
  "column name"
  property_version
  "column name"
  table_handle
  "column name"
  table_type
  "column name"
  token_data_id_hash
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"Streaming cursor of the table \"token_ownerships\""
input token_ownerships_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: token_ownerships_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input token_ownerships_stream_cursor_value_input {
  amount: numeric
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  name: String
  owner_address: String
  property_version: numeric
  table_handle: String
  table_type: String
  token_data_id_hash: String
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"columns and relationships of \"legacy_migration_v1.tokens\""
type tokens {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  name: String
  property_version: numeric
  token_data_id_hash: String
  token_properties("JSON select path" path: String): jsonb
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"Boolean expression to filter rows from the table \"legacy_migration_v1.tokens\". All fields are combined with a logical 'AND'."
input tokens_bool_exp {
  _and: [tokens_bool_exp!]
  _not: tokens_bool_exp
  _or: [tokens_bool_exp!]
  collection_data_id_hash: String_comparison_exp
  collection_name: String_comparison_exp
  creator_address: String_comparison_exp
  name: String_comparison_exp
  property_version: numeric_comparison_exp
  token_data_id_hash: String_comparison_exp
  token_properties: jsonb_comparison_exp
  transaction_timestamp: timestamp_comparison_exp
  transaction_version: bigint_comparison_exp
}

"Ordering options when selecting data from \"legacy_migration_v1.tokens\"."
input tokens_order_by {
  collection_data_id_hash: order_by
  collection_name: order_by
  creator_address: order_by
  name: order_by
  property_version: order_by
  token_data_id_hash: order_by
  token_properties: order_by
  transaction_timestamp: order_by
  transaction_version: order_by
}

"select columns of table \"legacy_migration_v1.tokens\""
enum tokens_select_column {
  "column name"
  collection_data_id_hash
  "column name"
  collection_name
  "column name"
  creator_address
  "column name"
  name
  "column name"
  property_version
  "column name"
  token_data_id_hash
  "column name"
  token_properties
  "column name"
  transaction_timestamp
  "column name"
  transaction_version
}

"Streaming cursor of the table \"tokens\""
input tokens_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: tokens_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input tokens_stream_cursor_value_input {
  collection_data_id_hash: String
  collection_name: String
  creator_address: String
  name: String
  property_version: numeric
  token_data_id_hash: String
  token_properties: jsonb
  transaction_timestamp: timestamp
  transaction_version: bigint
}

"columns and relationships of \"user_transactions\""
type user_transactions {
  block_height: bigint!
  entry_function_id_str: String!
  epoch: bigint!
  expiration_timestamp_secs: timestamp!
  gas_unit_price: numeric!
  max_gas_amount: numeric!
  parent_signature_type: String!
  sender: String!
  sequence_number: bigint!
  timestamp: timestamp!
  version: bigint!
}

"Boolean expression to filter rows from the table \"user_transactions\". All fields are combined with a logical 'AND'."
input user_transactions_bool_exp {
  _and: [user_transactions_bool_exp!]
  _not: user_transactions_bool_exp
  _or: [user_transactions_bool_exp!]
  block_height: bigint_comparison_exp
  entry_function_id_str: String_comparison_exp
  epoch: bigint_comparison_exp
  expiration_timestamp_secs: timestamp_comparison_exp
  gas_unit_price: numeric_comparison_exp
  max_gas_amount: numeric_comparison_exp
  parent_signature_type: String_comparison_exp
  sender: String_comparison_exp
  sequence_number: bigint_comparison_exp
  timestamp: timestamp_comparison_exp
  version: bigint_comparison_exp
}

"Ordering options when selecting data from \"user_transactions\"."
input user_transactions_order_by {
  block_height: order_by
  entry_function_id_str: order_by
  epoch: order_by
  expiration_timestamp_secs: order_by
  gas_unit_price: order_by
  max_gas_amount: order_by
  parent_signature_type: order_by
  sender: order_by
  sequence_number: order_by
  timestamp: order_by
  version: order_by
}

"select columns of table \"user_transactions\""
enum user_transactions_select_column {
  "column name"
  block_height
  "column name"
  entry_function_id_str
  "column name"
  epoch
  "column name"
  expiration_timestamp_secs
  "column name"
  gas_unit_price
  "column name"
  max_gas_amount
  "column name"
  parent_signature_type
  "column name"
  sender
  "column name"
  sequence_number
  "column name"
  timestamp
  "column name"
  version
}

"Streaming cursor of the table \"user_transactions\""
input user_transactions_stream_cursor_input {
  "Stream column input with initial value"
  initial_value: user_transactions_stream_cursor_value_input!
  "cursor ordering"
  ordering: cursor_ordering
}

"Initial value of the column from where the streaming should start"
input user_transactions_stream_cursor_value_input {
  block_height: bigint
  entry_function_id_str: String
  epoch: bigint
  expiration_timestamp_secs: timestamp
  gas_unit_price: numeric
  max_gas_amount: numeric
  parent_signature_type: String
  sender: String
  sequence_number: bigint
  timestamp: timestamp
  version: bigint
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached("measured in seconds" ttl: Int! = 60 "refresh the cache entry" refresh: Boolean! = false) on QUERY